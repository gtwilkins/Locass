/*
 * Copyright (C) 2017 Glen T. Wilkins <glen.t.wilkins@gmail.com>
 * Written by Glen T. Wilkins
 * 
 * This file is part of the Locass software package <https://github.com/gtwilkins/Locass>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "node.h"
#include <algorithm>
#include "shared_functions.h"

void Node::addSeed( NodeRoll& nodes, ReadStruct& read )
{
    // Redundant read, no need to append
    bool added = false;
    for ( Node* node : nodes.nodes ) if ( node->addSeed( read ) ) added = true;
    if ( added ) return;
    
    // Check posssible overlaps and splits
    NodeIntList ols;
    NodeIntIntList splits;
    int nodeCount = nodes.size();
    for ( int i = 0; i < nodeCount; i++ ) nodes[i]->addSeed( read, nodes, ols, splits );
    
    // Remove unfavourable overlaps and splits
    NodeSet fwdSet;
    for ( int i = 0; i < ols.size(); i++ ) ols[i].first->getDrxnNodes( 0 );
    for ( int i = 0; i < splits.size(); i++ ) get<0>( splits[i] )->getDrxnNodes( 0 );
    for ( int i = 0; i < ols.size(); i++ ) if ( fwdSet.find( ols[i].first ) != fwdSet.end() ) ols.erase( ols.begin() + i-- );
    for ( int i = 0; i < splits.size(); i++ ) if ( fwdSet.find( get<0>( splits[i] ) ) != fwdSet.end() ) splits.erase( splits.begin() + i-- );
    
    int32_t maxOl = 0;
    for ( int i = 0; i < ols.size(); i++ ) maxOl = max( maxOl, ols[i].second );
    for ( int i = 0; i < splits.size(); i++ ) maxOl = max( maxOl, get<1>( splits[i] ) );
    for ( int i = 0; i < ols.size(); i++ ) if ( ols[i].second < min( maxOl, ols[i].first->getBestOverlap( 1 ) ) ) ols.erase( ols.begin() + i-- );
    
    // Do splits
    for ( int i = 0; i < splits.size(); i++ )
    {
        if ( get<1>( splits[i] ) < maxOl ) continue;
        get<0>( splits[i] )->splitNode( get<2>( splits[i] ), nodes, 1 );
        ols.push_back( make_pair( get<0>( splits[i] ), get<1>( splits[i] ) ) );
    }
    
    if ( ols.size() == 1 && ols[0].first->edges_[1].empty() )
    {
        ols[0].first->addSeed( read, ols[0].second );
        return;
    }
    
    Node* node = new Node( read );
    nodes += node;
    
    for ( int i = 0; i < ols.size(); i++ ) node->addEdge( ols[i].first, ols[i].second, 0 );
}

bool Node::addSeed( ReadStruct &read )
{
    size_t it = seq_.find( read.seq );
    if ( it == string::npos ) return false;
    
    int coords[2]{ int( ends_[0]+it ), int( ends_[0]+it+read.seq.size() ) };
    add( read.readId, coords[0], coords[1], isRedundant( coords[0], coords[1] ) );
    readTest();
    ends_.init( read.tether[0], 0 );
    ends_.init( read.tether[1], 1 );
    
    return true;
}

void Node::addSeed( ReadStruct &read, int ol )
{
    int coords[2]{ ends_[1] - ol, int( ends_[1] - ol + read.seq.size() ) };
    string seq = read.seq.substr( ol );
    appendSeq( seq, 1 );
    add( read.readId, coords[0], coords[1], false );
    readTest();
    ends_.init( read.tether[0], 0 );
    ends_.init( read.tether[1], 1 );
    setOrigin();
}

void Node::addSeed( ReadStruct& read, NodeRoll& nodes, NodeIntList& ols, NodeIntIntList& splits )
{
    if ( int ol = mapSeqOverlap( seq_, read.seq, params.readLen / 2 ) )
    {
        ols.push_back( make_pair( this, ol ) );
        return;
    }
    
    int32_t coords[2], splitCoords[2];
    if ( !mapSeqEnd( read.seq, seq_, params.readLen / 2, coords, 0 ) ) return;
    coords[0] += ends_[0];
    coords[1] += ends_[0];
    if ( !getSplitCoords( splitCoords, coords[1], 0 ) ) return;
    coords[1] = splitCoords[0];
    
    if ( coords[1] - coords[0] > splitCoords[0] - splitCoords[1] )
    {
        Node* node = splitNode( splitCoords[1], nodes, 1 );
        node->drxn_ = 2;
        ols.push_back( make_pair( this, coords[1] - coords[0] ) );
        assert( false );
        return;
    }
    
    splits.push_back( make_tuple( this, coords[1] - coords[0], splitCoords[1] ) );
}

void Node::printSeed( Querier &bwt, NodeSet nodes[2] )
{
    struct BadPair
    {
        BadPair(){ edges[0] = edges[1] = NULL; redundant = false; };
        ReadId id;
        string seq;
        BadPair* edges[2];
        int ols[2];
        bool redundant, drxn;
    };
    
    vector<BadPair> bps;
    NodeList allNodes( nodes[0].begin(), nodes[1].end() );
    allNodes.insert( allNodes.end(), nodes[1].begin(), nodes[1].end() );
    for ( bool drxn : { 0, 1 } )
    {
        int32_t limits[2];
        bool first = true;
        for ( Node* node : nodes[drxn] )
        {
            if ( first || ( drxn ? node->ends_[0] < limits[0] : limits[0] < node->ends_[1] ) ) limits[0] = node->ends_[!drxn];
            first = false;
        }
        limits[1] = limits[0] + 1500;
        limits[0] -= 1500;
        for ( Node* node : nodes[drxn] )
        {
            for ( ReadMark &mark : node->marks_[drxn] )
            {
                if ( mark.estimate < limits[0] || limits[1] < mark.estimate ) continue;
                bool found = false;
                for ( Node* t : allNodes ) if ( t->reads_.find( mark.id ) != t->reads_.end() ) found = true;
                if ( found ) continue;
                BadPair bp;
                bp.seq = bwt.getSequence( mark.id );
                bp.drxn = drxn;
                if ( bp.seq.length() < 200 ) continue;
                bps.push_back( bp );
            }
        }
    }
    
    for ( BadPair &bp1 : bps )
    {
        bp1.ols[1] = params.readLen / 2;
        if ( bp1.redundant ) continue;
        for ( BadPair &bp2 : bps )
        {
            if ( &bp1 == &bp2 ) continue;
            if ( bp1.seq.find( bp2.seq ) != bp1.seq.npos ) bp2.redundant = true;
            if ( bp2.redundant ) continue;
            if ( bp2.seq.find( bp1.seq ) != bp2.seq.npos ) bp1.redundant = true;
            if ( bp1.redundant ) break;
            int ol = mapSeqOverlap( bp1.seq, bp2.seq, bp1.ols[1] + 1 );
            if ( ol )
            {
                bp1.edges[1] = &bp2;
                bp1.ols[1] = ol;
                if ( !bp2.edges[0] || ol > bp2.ols[0] )
                {
                    bp2.edges[0] = &bp1;
                    bp2.ols[0] = ol;
                }
            }
        }
    }
    
    vector<BadPair*> ends[2];
    for ( BadPair &bp : bps )
    {
        for ( bool d : { 0, 1 } )
        {
            if ( !bp.edges[d] && bp.edges[!d] )
            {
                if ( bp.edges[!d]->edges[d] != &bp || !bp.edges[!d]->edges[!d] )
                {
                    bp.edges[!d] = NULL;
                }
                else
                {
                    ends[d].push_back( &bp );
                }
            }
        }
    }
    vector<string> seqs;
    vector<int> olTotals;
    unordered_set<BadPair*> used;
    for ( bool d : { 0, 1 } )
    {
        for ( BadPair* bp : ends[d] )
        {
            int drxns[2]{0};
            drxns[bp->drxn]++;
            vector<BadPair*> path = { bp };
            while ( path.back()->edges[!d] ) path.push_back( path.back()->edges[!d] );
            if ( d ) reverse( path.begin(), path.end() );
            string seq = path[0]->seq;
            int olTotal = 0;
            for ( int i = 1; i < path.size(); i++ )
            {
                drxns[path[i]->drxn]++;
                int ol = path[i-!d]->ols[!d];
                seq += path[i]->seq.substr( ol );
                olTotal += ol;
            }
            if ( used.find( path[0] ) != used.end() && used.find( path.back() ) != used.end() ) continue;
            used.insert( path.begin(), path.end() );
            if ( olTotal < params.readLen * 10 || seq.length() < params.readLen * 2 ) continue;
            seqs.push_back( seq );
            olTotals.push_back( olTotal );
            cout << ">" << drxns[0] << " " << drxns[1] << endl << seq << endl;
        }
    }
    
    MapNode* mn = new MapNode();
    mn->seq = "CCCCCCCCCCCCCCCCCCTACTGAGCGAAATTTATCGGCCGGCACGATTTTCGAATTTCACCACACTAAATTAAAAATTGATTTCAAATTTGGGTCTCCCCTAAGGAATCCTGGACCCGCGCCTGTAGTAAGCACAATTTTTATTTACTGAACCCCCCCCCCCTTAAGCAAAAACGAAAAGAAGGTAAGATTGTGGATACTATCTTGGTTTAAATATAATTTTTTGCCAGGGGTGGGGGCTCGTCTTCTTTTTTCATTTTTTTATAGGTAAAATTGTGGTTACCGTCTTCGTTTTTAATTTTTGTTGTTGTTGCCAGGAGTGGGGTCCCGTACGGTGCCACCCCCATGCCCCCACGCTGGATCCGCCACTGCTGTGAACGCCTATAGACATTGCATTATTTTGAAAAATGAAGCACAGAAGCACGCGGCATAATCTAACTTTTAAAATGATTTGAGACCAAAGAAGCACATTTTTTGTTTTCATAGGTTTTTATTCATTTCTCTCAAAGAAAAATTATACATTTATAACATTGGATACAAAATAACAAAATAATTTAACATAGGTCTTTATAAATTTACCAATGATCTTTTACATTTACATACAAAAGTTACACCTCTTCATTTTCCTTTGGAGACAAAAAAATTATATATATATATATATATAAAAAGAGAAAATGCTACAAAACACCTACTACCCCCCCCCACCCCACACAACATTTAAACACATAACAAGTACAACAGTATACAAAACACACACTAACATAGAACGAACAAACAAACAAAAGTAGAGGGGGAAAAAAAAGAAAAGAGAGAAGAGAGGAGGGTCAGGAAGTTGTATATTGAGAAAAAAAAACTGAAAACATTTATTCTAAACTTTCCAAAGCTTCCCATTTCCTTAAATGAATTGAAAGTGTGTCTCTTTCCATTGAAAGTTTTTTCTCTTCATTTCTATTTTCCAACAATCTATATTCTATTTCTTTTGCTTTTGGAGGGTTTCCCTTCTCTCTACTGTGGAAAATCATATATTTAATCAAAATTAAAATGTGGTTCAATAATTGCTCTGTTTTAAAAGTAGTGTCATCTATTCCTATATGAATTTCTTTCCAGGATAATTTCTTCAGAATTGGTAAATTAAGTCTATCTCCACATTTCCCCCAGACTTCCTTTATTGTATTACATTCAAAGAATACATGTTGATAAGTTTCTTCAAAATTTTTGCAAAATGAGCACAAACCATTTTAATGGAACCTGAATCTATGTAAATGATGATTTGTATATAAAATATTATGCAATAATTTGAACTGAAATTCTCGCAGTTTACTACTTAAGGTACACATCCTTGGTTGAACATATATCTTTTCTACTTCTTTTCTTGGAATATTGTAAAGTGTCATTAAATTGTCGCCTGCCGAGTTTGTTTCTACATTCTTTTTAATTTGACTCTTATATACCATTTTTGCAGTTAAATCTTCAAATGTAAACACTTTCTTTGAACAAAATAAATTTTAAACTAAAGCCAGTGTGAATTGACTTTCTTAAAGGTTGAACACTCTGTTTCCATTCATAAGGGGCTACTTTATAAATTTTGTTTACTTTATCTATTTCCACTCTGCTCAAACCTAACATTATAAAATGAGCTTCAGGTTTCAATTCTCCATTTTCTTCACAAATGTGATGAAGTCGATATATATTTTTTAAAAACAAAGTTTCCTCAAATAAGGTTTGACCTTCTAGTTGAATAAAATTATTATTATACAATATTTCATTCCCTTTGTATCTCTCTTCTGTTTTAACATATTCTTTCATATCTATCCATGCTTTCAGAAGATTCTGATAAAAGGAAGGTAACATAAGTTTCACTGTATCTCTCCAATAATTGCAATAATATATTAAATTACCTCCTATCGGTCTCATTAAATATTTAAAGTATTGTTTCCATTTGATATCATGAGTTCCTGTTACAAGCCTTTTTATCCACATTATTCTTTGTGCTTTTACAAACAACCTAAAATTCATCATTTTGAGCCCACCCTGCTGATAGTCTAACATCATTGTACTTCTTTTAATTTTATCTTTACCTCTCCACAAAAAATCAAAACATATTACTTCCATTTCTTTGTATACCCTCTGGAACTGGCATTAGTGATGTTACATATGTCAATTTAGAGTATCCATATACTTTCATCAATTGAATTTTACCCATTAAAGTTAGGTCACGCTGTTTCCACCACGTCAGTAGTTTTTTACTTTTGCTCAATATTTCCTTATAATTCATTTTTTTCTCGATATCTACATGAACTGAAAAATAAACACCTAATATTTTAACAGCATCTACAAGTTTCCCAACGGAAATGTATTATTAGACACCTGTGGGCCCAGGGGCAGAATATATGTCTTATCCTTGTTTAACTTTAATCCTGATATTTTATAAAAAACCTTCTAAAACGTGTTCTATTTCCTTAACTGAACTCATATCTTTGATGAAGAGTGTTATATCATCAGCATATAATACTTGCTTTATTTCTGTATTTCCAAAACAAATTCCTTTTACCAATTGATTATTTCTAATCATATGAGCTAAAATTTCAATGCATAAAATGAACAAGTATGGAGATAATGGGTCTTCTTGTCCAATTCCTCTTTCAACCTTAAAATAACCTGTTGATGCGTTTCCATTCATAACACAACTTTCAGTATTAGTATAAAGTATATTCACCCATTTACAAAACAATGGTCCAAACCCAAATAAATTTAAGACTTTGTATAGAAAACAATGAGAAACAGAGTCGAATGCCTTTTCAAAATCTAAGGCCATCAAAAAAGCATTTTCCCTATAAAAAGAAGTATGAAAAATCATGTCATCTATTATTCTTATGGCTTTTCCAATGTTTCTATTCTTAACATAGCCAAGTTGATCAGAAGATACAATATCAGGTAAAATTTCTTGCAATCTCTTTGAAAGTATCTTTGTTAAAATTTTATAATCCACATTTAAAAGAGAAATCGGTCTGTAATCCTTAATAAAGTCTGAATCTTTATCTTTTTTTATGTATCAAGGTGATAACTGCTTGTCTCTGAGAGGCTGATAGTTCTCCATGATTAAAGGCTTCATTAAAAGATGCAAGGATTAGATCTCCAATTACCGGCCAAAATTTAAGATAAAACTCTACACTTAAGCCATCATTTCCTGGTGATTTATTTAATTTCATATTTTTTAATATTTCTATACATTCCCTTTCTACTATCTTTTCTTCACCTAAACCCCTTAAGGTCTCGTTCAATTTTGGCATGTTACTAGGGGAAAATTCTAAACCTCCATCTAGTACAACTTCTATTTTTTTTATACAACTGACTGTAAAAGTGTTTTATTCCCTCGACAATTTCTTTTTCCTTAGTAACAATCTTTCCGTTTACGTTTAATTGCTGTATTACACTTTTCTTTCTATTTGCTTCCATAAGCTGTTTAAAAACTGCTGTATTCTTCTCTCCACATTCATACCAAGAGGCCCTTGATCGTATTTTTAAACCTTCATTAATATAGTCATAAAGTACTCTTAGTTGTTGTTTCTTAATTTTCAGTTGTTCAAGGATATTTTTATAACGTACATTATTGATTGATAGTAAATTTTCTTCCAAGTCTTCAATTTCTTTTTCTAGCTTTTCTATTTTTTCCTTCCTTTCCCTTGCCCTTTTCTTTGAAAATTTAGTTGTAAACCTGCGTATTTCCATTTTGATATAGTCCCATAATACTCTCTTGTCTTTTATCTCAGATAACATTTCGTTCTTTAAAGTCTGTATTTCTTCCTTCATCTTTAAAACATAGTCTCTATCATTTACGAAGCTATTATTGAACTTCCAATAACCTCTTTTACCCTGAAAATTTCCAGACGTTCTATCATGCAGAACCAAATTAACAGCTGAATGGTCAGGTGCTAAGGAGGGAATAATGTCACATTTAGATGTTATCTGTTCTAAATTCTCTGATATAATGAAATAATCCAAACGGCTTTGCATAAATGGATTCCCTTGTCTATAAGTATATTGTTTTTTATCTTTATTTTTATTTCTCCATACATCTCTTAATTTAAATTCATCCATGAATTCTTCTAATTTGCTACTGAATTTTGATTGCTTCTTTGGAACTTGTCCAAAATCATCTAAGTTCTTGTCTCTAATAACATTAAAATCACCTCCAAGAACTACTGGGTTCCCTTCTGAATTGTTTCTATACAACAACTCCCTTAAATCCATTAAACATTTCATTTGCTCCCCTTCGTTATTTCCAGTAGGAAAATAAACATTTCCTAGCAACATCTTCTGACCTTGTATATTACATCTAATCAATACATATCTTCCATTTATGTCTGCACAAGTGTCACTAATTTCAATGTCTAACTTACTATTTATTAATACCAGAACTCCTCTACTGTGGCTTGTACCATGACTAAAGATACATTTCCCGCCCCACTCCAATTGCCATTTCTTTTCGATATGTTTCTTGTAAGTATATTATATCTATAGACTTTGTCCTAAACCAATTAAACATTTTTTCTCGTTTGCTTCTATCTCTAATTCCCCTCACGTTTAGTGTGAGATAGTTACATGAAAACAAGTTCCCTTTATTATCCATCTTTTTTCTTTTGAAATAAACCCATATCTATATATGAGTTGGGACCCTCTATAAATTCCGACCTTGCAGATAAAGGAATCAACTTTTGGCAAATTAATATTTTTAATGAAACAACCTCACGACCCTCTCCCCTACCAGAAAGGAAATTAAGAAAGAAAAAGGATATGTATACATACATGAGACTACTACAAATATTCGAGAACATACATTTGAAAAACAAAAAAAGAAAAGGAAAGAAAAAGAAAAGAACACAAGGAAACATAAGATGACAACATGAAACAGACAAATAACAGAGTTCGCGTGGCGAATCATACATGATGACTAATCAGACTGCCTTGCAAACGTTGCATGGCAGTCCCCTCCCCCCCCTCTCCCCTCTCCCCTAATTCAGCTTTCCTACTTATTTGTCATACAGCCTGCAATTGAAAATTATGGACTGTCTGACCTTTGTTTCTACATTTCCCTGTTCAAAAAAAATAAATAATATCTTCCTGCAAATCTACTACATCATGGTCTTTTTCCATGTAAAGGTAAATCAAAATAGAGGATAAACCACCCTCTATGCTATCTCCATCTCAATTCAACACTGTTCTTTCCTGCCTAGTATACAACTTGCAATTGCTATCTCAATCTCAATTCAAAACTTTTCTATCCTGCCTTCATTGTATAACGCTTACAATTCAAGACTATGCCATATCTCCCCTTCTTTCTACATTCAACAGTTCACAAAACAAATACCTTACTATACCTTACAGATCGACTACATTGTAACTCATTATCATTTGGATTAAGGTAGTGTTCCGAAACTGCTGCAAGTAAAATTGCATCGAGAAACTACTTCTCTTTTAACATTTGCAACAACACAGCACAGCAACAAAAAAAAAAAAAAAAAATTACTCCATCAATAAATATTCCTTCTGAGTTGCTTCTACAGTGTAAATACATTTCCTCTGTGCTATCTCCATCTCAATTCAACACTATTCTCTCTTGCCTTCATTGTACATACAGCTTGCCCTTTCAAACTACAGTATGCCATATCTCACCTACTTGTACATTCCAGTTAATAAAACCAATGACTTCCTGCATATCAACTGCGATTACATCAATGGTCTTTTTCATATTGGAGTACAACAAAAGAAGGGTTAAAACCCCCATGTATAAGTTATCATATGTCCAGCCCAGCATCTTCCCCCATTATTATGCCTTTTATCTACTAACCAAAGTACATGTGCTTCCTTTCTGTCAGTCTTCTGTCATTAATACTTGGATTAAGACTGTACTCTGAAACTAACCTAAACAAATTTGCATGAAGAAATCCCTTCTCTTTCATGTTTGTAATAACATATAAAGAATTCATACTCTCTACCTTTCTTTTTCCGTGCAAGAAATATTTCCACTCTCAACTTTTCAGAAGGAAATAGTCTACATATAATATTTCTTCAAAATAGCTCCTCTATTACATTTCCTCTGTGCTTTCTCAATCTCAATTCAAAACTTTTCTATGAATATGGCCTGACCCATAATCGTTCGATCAGCCTAAACCTGGTACAAGGCGACTTTGACCAAACTTTCAAAAGACCCTATCGTGCCCAGTCACCCGTGGCAGAAATGTTATGAATGGGGTATCATTGGACAGAAGAGATGTTACTCGCCATCATGAAATAAATTTCAAAGTCATATTGTTTGTGATATTCTAATAAAGAGCTACCAAAGTTGGGTACATTTTTTTGTAAACTCACTGTATACATAGAGAGAGAGAGAGTGGGGGAGGAGAGAAGGGAAGAGGGGGGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGATCCTGCTACTACTACTGCCGCTAGGTTACTGCTATAAAAACTACTATTTCTTAAAAGGCAAGTACACTCCAAAAATACCTTATTTTCAATAGAAATCAGACAATATGTAATCAGACAATTATTTCCCTCACTTTCACTACTATATAATATTTCTTTTGTCTATCTTCTTCTTCTCTCTCTCCCTCTCTCTCTCTCTCTCACACACACATACACACACACACATACACACTCACACACACTCTCTCTCTCTCCCTCTCTCCATCTCACTCTCATCTCTGTGTTTGTCTCTTTGTCTCTCCCTCCCCCCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTATATATATATATATAATCAGACAATATATAATACCTATATCCCTCACTCTCACTTTCTCACTCCCTCTCGTTTTTTTTTTCTCTCTCTCTCTCTATCTATCTCTATCTCTACCTATCTCTCTCTCTCTCTCTCTCTCTCTTTTTTTTTCTCTCTCTCTCTCTCTCTATCTATCTCTATCTCTACCTATCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTATCTCAATCGATCAATATCGTGATCAATCCAGCTGCATAAGGAAAACAATTATTAGGGGCTATAATATTGAACGCTTCACAAGTATTAGTATGAGTTCAGTTATATATTTTTATTTGACAAGTCTTGACAAATTCAGTATCAATAAGAGTTTAACAATTCGTCAACATTTCATGCACCTTTCACTGGCTTTGAGTCTCTTGTATCTGAATTTTAGACACAATAATGTTTTAGTCTCTGGTAAGATATGCATTCTGTCCAAGGAAAGACATTAGTGACTATTAGTATATTTACACAAGCAATCTTTTTTTATACAAATTGTACACCTCGGCGACCACATTGACGTCTTCTTCATTGACTGCGATCTCAACCACTTCAGGTGGTGAAGATGTCGTTATGCTTTCCGTCGTTGGATGCTCCTTCTCCTCACTTTCATTCTCACCCCAACGTCCTCGGTTACCATAGGGATGACGGTGGCCATCACGCCTGGGAGATCCTTCTTCGGTTCCGTTGCGTCTGTCGAAGGGACGGTCTCCGAAAGGCTTTCTACCGAAGGGGTTGACCCAGAAGGGCCTCATCTCAAACATTGGTCTGTCCTGATCTCCATCTCCGGTCTTGTTGTGATGACGATGGGGGTGATCTCCCGTCTCATTATGACCCTGGTGACCTTCTGTGTGGTTGCGTCTGCCGAAGTGGTTGAACCGGAAGGGCCTCGTATCATTTGGTTTGTCCTGATCTTGATCTCCCGTCTCATTATGTCCTTGGTGACCCTCTGTCTGGTTATGATGACGGTGGTGGTGGCCATGGTGGCCATGGTGGCCATGGTGGTGAGGGTGAGGACGGCCATCCTCCTCGTTGCGTTCATTGCGCTGGCCGAACGGTTGTTCCTCTGGTCGGTCCTGAGGTGGACCTTGACGGTGACCATGATGACGACGTCCATGACCATCAAACTGACCGCGCCCTCCTAGACCATCACCAATTTGTTGGGCAGCATCAGTTTCTTCTTCTCCATCACCACGCCTTCCTCCTTGGCCGAAGAAAGGTCTTCCTCCAGCACCATCTGGTCTGGAGCCACCAAATCCAGGTCCGTCGAATCTCCTACCACCCATCGGACCGCCATTTTGTCTGCGTCCATCCATATGTGGGGCACCAAATCCAGGTCCATCGAACCTCCTTCCACCCATTGGTCCACCATCTTGCCTAGATCCACCCATCTGCATTCCACCAGGCCTTCCTCCAAAGCGACCTTGTCCTCTCTCTCTGCCATTCTCATTTCCTCGCCGTTCATTGAAATCTCTTCGTGCGTGAGCTGTAAGGGTTAATGAAATAATCGAATTAATTAAGTAATCACATTCTGCATTATTATATTTTGCTCTACATTGGTTTATAGCAGGTGACAAATAAGAATGGTAACTCGCCTTCTTATATTTTTCCCTTTATGTTTAATCCTAATCCGTAAATGCGGTTCGATATTCAAAACGCCTAATTCTGACTGAATTAAATTTGATTACCAGATTGAACGTAAACATAATACACATCCTTTGTCATTCAGAAAACGGATTGGTGTAGGCTTAATAAATACAATTAATTATATTGTGTAACGAACAATTTAAAAATGCATATTACAAACTATGAAATAATCATATTTACTTCTGTGAGCCCTTCATTGGCTTTATATTTAGCACTTATGAAGTAATACCGAGTAAAATTTGATTTCTTACCCGAGATAGCAAGAGCAGCCACAATGGCAACGATCAATGTTGCTTTCACCTCCATGTTTGTAAGGTCTCTCCGATGCTACAAGCTTTCTCTAGATTCGTTGCCTTCCAAGAGAGAACTAGCTCCAAACTTAACAACTACCTGCTGGGCCACTGAATTTATAGGTTTTCTACCCTAGATTGATATCTCACACTAGTACCAGACCGTGTCAGGAATTACCAGGCATACCCTGTTCTAGTTGATCTTTTCCCCCTTTTTTTCTTCATTTTCACACTGTGTTAATATCTTTAACCTTTTATCAACCACTGATTTGGAGAGTGCGTTGTACGTACTAGTACCAAAACCAATTACTTATCTTCGGATATCCGGTAGAGCCATGTATTGGGTGACACCGATGTCGCGGCGTAGTACAGTAGTGACCCCTTGAGTTTGTGAGGGAGCTAACGGTCATCGGTTTCTCTCTCTCTCTCTCTCTCTCTCCCTCCTTCTCCTTCTCTCCCCCGATCCTTCTTTCTGAAAAAATTGCATTGATTCGAAAGCCATTTAACAAAGTTGTCAAAGAATCTAGGCAATAACAACATCATCATTACAATCATTATCATTACCATTATCATCATCATCATTATCACCATCAATATTCTAGTCATCATTTTCTTCGTTATCTTACAGTCGTCATCATCATCATTACCATTATCATCATTATCATCATCATCATAATCATAATCATCATTCGGAAATTCAAAAGTAATTCAGGACATCCGTTGAAACAGCCCCTCGTTCGTATCAACTCATATCAGTTACGATTCTAATAATTACATAATTATATCCACATTCTGAAGTTAACCTAATGGTGTATAATGCATTGTGAATGAATTGCAATTGCGTCCCTTGAAAATTATTTCGTCTCCCACAATTACAAAATTTTTGTGTAAGAACAGCATTTCTGTTCTGTTTTCAGTACCGAATTTATTATTCTAAATATGTATTTATCGAAGGGTCATGATAAATAAACATCCGGGGTAGTGAGCCTTCGGAAAACTGAAAAATCAATAATTCTTTTGATAAGGACGGTATATGTAAATCTAGCAAGAGCCTCCCTTTACATTTTCCTAGGCTTATTGCCTAATCCAGCGTTTTTCAACCGATGTGCCCCAAGACATTTTTAGGGTACCACAAAAGAATTTGAAGAATATATAAGATTTTTTTTTTTAATTCTTGGAATAACGTCGATTTCTTGAAAACCTTAACAACCACTGAAGTATGTAATTTCATGAGGAAATAGCAATTTACTGGATAGAAAATTGTCTTTCTTCCTTGCTCGCTTCACTCCTTCGCAAGACTTAGAAACATGATGATTTCTATCAACGAAGTGCCTTAATATTTGAGCATTGAGGTGCCCGAATAGCCTTCTATTTGACAGTTAGGCGCCCACATAATTATGTGATATATCTTTTATATACAAATTTCAATTTTACCACGCTCGTTCCCTTCACTCGCTCGCAACATTTAGGGATAATTCTGGGCAATGAGATGCCCGAATCTCCTCATATTCGTGCTTCGAATTGACTGCACATATTGAGTTTTGTATCAATGTATTCGGCAGCGAGGTGCCTGCACGTTTATTTTTATATTTTATCTAGTGTGTTGACTATAAAGTCAATTTTTAACGTATTAAAAGTGTGATGGAGCGGGACGAGTGTCAGAGTGATATAAGATGAATCTTCTGAATATTAATTTGGGATTAGGGTGACGCGAAACCTTTTTGTTTCTTAAAAAGGTGCCTTGACTAAAAAAAAAAGGGTAAAAAAACGCTGGCCTTCACGTTGATCTAATCCAATGAACTATAATTTCTTACAAGAAGAAACAAAAGCTTGTGTTCTTGCTGGAAATGGCTTCCCCAGACTAGCAATTAGTCAAGTAAATGGGGAGGCACGGGGCATATCCTCCGCCCAATCGAAAGCCAAAACATTGTTTTATAACAAATAAAACAAAACACAAAAACCCAGAGGTAACCGTTTTTAGATAGAAAAGGAGTAGCAGAGCGGAAAGAGAACGAGAAAGCAGATTGGTTGAGAGCTCGTCACGTGACCAGAAACATTTCATCTATTAAAGTACTACTGTATATGAGTGTACTATTTGGGAGTTAGAAAAAAAATGTGGATTTTTTTTTTTTTTTAATATAATTTTTTCTTTTCTTTTTCAAATCTTAATTTAATGAAAACAAAATATTTCAAATCTTTTTAGATAAAAATTGATATTTTTGGGGTCTAAATTTTTGTTTTCTAAATGGTATTTAAAAAATAAATAAATAAATGTTTGATGCAGGATATAAAAAACAAATATGGACTGCTCTGTAATCGGATGATGGTGAGAAATACCATTCCCTCGGTGGTGTTCACACCGGCCCTTCTATCACCCCCTCGGCTTCGCCTCGGGGTGATAGAGGGGCCGGTGTGAACACAACCTTGGGAGTGATAGTTCCCACCATCATCCTCATGAGCAGTCAATATTTGTATACTATTTTCTCCCTCTGTCTGTCTCTCTCTGTCTCTGTCTCTGTCTTTCTCTCTCTCTCTCTCACTCCCATCTCTTTATCTCTTTGTTTCTCTCTGTGTATGTCTCTCTCTCTCTCCCCCTTTCTCTATCTCAGTGATCTATCTCTATCTATCTCTATTTCTGTCTGTCCCTTGCTTTCTCTACCTTTTCTATCTATTTCACCCCCTCTCTCTCTCTCCCTCTCTCTCTCTCTCTCTCTTCTCTCTTAATCCCATCTTTCTCTGTCTGTCTCCCTCTGCCTTTCTCTCTATCTATCTCTCTTTTACCTCTTCAACCAATCAATATCGTGATCAATCCAGCTGCATAATAAAAATATATAAGGGGCTTTAATATTGAACGCTTCACAAGTATTTGTACGATTTCAATTATATATTTTTATTTAACAAGTCTTCAAAAATTCAGTATAAATAAGAGTTTGATAATTCGTCAGCATTTTTATGCACCTTTCACTGGCTTTCAGTCTCTTGTATCTGAATTTTTAGACACAATCCATGCTGTTGTCTCTGGTAAGATATGCATTCTGTCCAAGGAAAGACATTGATGACTATTATCAATATATTTACACAAGCAATATTTTAAAAACAAATTCTACACCTCGGCGACCACATTGATGTCTTCTTCATTGATTGCGACCACTTCAGGTGGTGAAGATGTCGTTACGCTTTCCGTCGTTGGATGCTCCTTCTCCTCACTTTCATTCTCACCCCATCGTCCTCGGTTACCATAGGGCCGACGATGGCCATCACGCCTGGGAGATCCTTCTTCGGTTCCGTTGCGTCTGTCGAAGGGACGGCCTCCGAAAGGCTTTCTACGGAAGGGGTTGAACCGGAAGGGCCTCATCTCGAACATTGGTCTGTCCTGATCTCCATCTCTGGTCTTGTTGTGATGACGATGGGGGTGGTCTCCCGTCTCATTATGACCCTGGTGACCTTCTGTATGGTTGCGTCTGCCGAAGGGACGGTCTCCGAAAGGCTTTCTACCGAAGTGGTTGTACCGGAAGGGCCTTGTATCATGTAGTTTGTCCTGATCTTGATCTCCCGTCTCATTATGACCTTGGTGACCTTCTGTGTGGTTATGATGACGGTGGTGGTGGCCATGGTCGCGATGGTGGTGAGGGTGAGGACGGCCATCCTCCTCGCTGCTTTTGTTGCGCTGACCAAACGGTTGTTCCTCTGCTTGGTCCTGAGGATGACCTTGACGGTGACCATGATGACGACGTCCAGGACCATCAAACTGACCGGGCCCTCCTAGACCATCACCAATTTGTTGGGCAGCATCAGTTTCTTCTTCTCCATCACCACGCCTGCCTCCTTGGCCGAAGAAAGGTCTTCCTCCAGCACCAACTGGTCTGGAGCCACCAAATCCAGGTCCGTCGAATCTCCTTCCACCCATCGGACCGCCATTTTGTCTCCGTCCATCCATCTCCGGGGCACCAAATCCAGGTCCATCGAACCTCCTTCCACCCATTGGTCCACCATCTTGTCTCCGTCCATCCATTTGTGGGGCACCAGAGTCAGGTCCATCGAACCTTTTTCCACCCATTGGTCCACCATCTTGCCTAGATCCACCCATCTGCATTCCACCAGGCCTTCCTCCAAAGCGACCTTGCCCTCTCTCTCTGCCATTCTCATTTCCTCGTCGTTCATTGTAATCTCTTTGTGCGTGAGCTGTAGGGGATAATGAAAAATACAAATCGAATTAATTAAGTGATCACATTCTGCATTATTATCTTCAGCTCTACATTGGGTTATGGCAGGTGACAAATAAGAATGGTAACTCGCCTTCTTTGATGTTTTTTCCCTTTATGTTTAACCCTATCGGTTCGATATTCAAAACGCCTAATTCTGACTGAATTGAACTTGAATACCAGATTGAACATAAAGATAATTCTTATCTTTTGCCATTCGACCAACGGATTGGTGTAGGCTTAAGAAATAATATAAATTATTTTGTGTAACGAACAATTTAGAAATGCATATTATAAAATATGAAATAATCATATATACTTCTGTGAGCTATTCGTTGGCTCTATATTTAGCACTTATCAAGTAATACCGAGTAATAATTTGATTTCTTACCCGAGATAGCAAGAGCAGCCACAATGGCAACGATCAGTGTCACTTTCACCATGTTAGTAATAGGTCTCTCCGATGCTATAGCTTTCTCTTGATTCGTAACCTTCTATAAGAGAACGAGCTCCAAACTGAATAACTATCTGCTGGATCACTGAATATATAGTCTTTCTAACATAGATTAAAATCACTTTCGTACCAGACCGTGTCAGGAATTACCAGGCATACCCTGTTCTAGTTGATCCCCCCCCCCTTTTTTTCTTTATTTTTATACTTTGTTAAAAAAATTTGAACCTTATATCAACCACTGATGTGGAGAGTGCGTTGTACGTACTAGTACCAAAACCAATTACTTCATCTTCGGATATCCGGTAGAGCCATGTGTTGGGCGACACAGATGTCGGGGATGTCGGGGATTACATTAGTAGTCACCCTTGGAGTTTTTGAGGGAGCAACGGTCATCGATTTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTCTTTCTCTTTTTCTCCCCCTTTCCCCCTATCCTTCTATTTGAAAAATTGCATTGATTCGAAAGCCATTTTAAAAAGTTATCAAAGAATCTAGGCAATAACAACATCATCATTACAATCATTATCATTACCATTATCATCATCATCATTATCACCATCAATATTCTAGTCATCATTTTCTCCGTCATCTTACAGTTGTCATCTTCATCATCATACCAATCATAATCATCACCATCATCATCATCATCATCATCATCTTCATTACCATTATCATCACTATCATCACCATCATCATCATCATAATCATTCGGAAATTAAAAAGTAATCTAGGACATCCTTTGAAACAGCCCCTCGTTCGTATCAACTCATATTAGTTACAATTCCAATGATTACATAATTATATCCACATTCTGAAATTAACCTAATGGTATATAATGCATTATGAATGAATTGCAATTGCGTTCCTTGAAAATTATTTCGTCTCCCACCATTACAACTTTTCTGTTACATACCTTTACTCTTTGACAAGAAGTCTGTTTGACTATAATTTGCAACAACATTTCTGTGTAAGAACGGCATTTCTGTTCTGTTTTCCAGTACCGAATTTATTAGTCTAAATATGTATTTATCGAAGGGTCGTGAGAAATAAACATCCGGGGTAGTGAGCCTTCGAAAAACTGAAAATCAATAATTCTTTTGACATGGACGGTATATGTAAATCTAACAAGAGCCTACCTTTACATTTTCCTAGGCTAATTGCCTAATCCAGCGTTTTTCAACCGATGTGCCCCAAGACATTTTTAGGGTACCACAAAAGAATTTGAAGAATATATAAGATTTAAAAAAAAATTCTTGGAATAACGTCGATTTCTTGAAAACCTTAACGACCACTGAAGTACAGTATGTAATTTCATGAGGAAATAGCAATTTACTGGATAGAAAATTGTCTTTCTTCCTTACTCGCTTCACTCCTTCGCAAGACTTAGAAACATGATGATTTCTATCAACGAAGTGCCTTAATATTTGAGCATTGAGGTGCCCGAATAGCCTTCTATTTGACAGTTAGGCGCCCACATAATTATGTGTTATATCTTTTATATGAAAACTTCAATTTTACCACGCTCGTTCCCTTCACCCGCTCGCAACATTTAGGGATAATTCTGGGCAATGAGATGCCTGAATCTCCTCATATTCGTGCTTCGAATTGACTGCACATATTGAGTTTTGTATCAATGTATTCGGCAGCGAGGTGCCTGGACATTTAATTCTATATTTTATCTAGTGTGTTGACTATAAAGTCAATTTTTATCGTATTAAAAGTGTCATGGAGCGGGACGAGTGTCAGAGTGATATCAAATGAATCTTTTGTAAATTAATTTGGAATTAGGGTGACGCGAAACCTTTTTGTTTCTTAAAAAGGTGCCTTGACTAAAACAAAAAGGGTAAAAAAACGCTGGCCTTCACCTTGATCTAATCCAATGAACTATAATTTCTTACAAGAAGAAACAAAAGCTTGTGTTCTTGCTGGAAATGGCTTCCCCAGACTAGCAATTAGTCAAGTAAATGGGGAGGCACGGGCATATCCTCCGCCCAATCGAAAGCCAAAACATTGTTTTATAACAAACAAAACAAAACACAAAAACCCAGAGGTAACCGTTTTTAGATAGAAAAGGAGTCGCAGAGCGGAAAGAGAACAAGAAAGCAGATTGGTTGAGAGCTCGTCACGTGACCAGAAACATTTCATCTATTAAAGTACTACTGTATATGAGTGTACTATTTGGGAGTTAGAAAAAAAATGTGGAATTTTTTTTTTTTTTAATATAATTTTTTCTTTTCTTTTTCAAATCTTAATTTAATGAAAACAAAATATTTCAAATCTTTTTAGATAAAAATTGATATTTTTGGGGTCTAAATTTTTGTTTTCTAAATGGTATTTAAAAAAAATTAAATAAATGTTTGATGCAGGATATAAAAAACAAATATGGACTGCTCTGTAATCGGATGATGGTGAGAACTACCACTCCCTCGGTGGTGTTCACACCGGCCCTTCTATCACCCCCTTGGCTTCGCCTCGGGGTGATAGAGGGGCCGGTGTGAGCACCACCTTGGGAGTGATAGTTCCCACCATCATCCTCATGAGCAGTCAATATTTGTATACTATCTTCTCCCTCTGTCTGTCTCTCTCTGTCTCTGTCTCTGTCTTTCTCTCTCTCTCACTCCCATCTCTTTATCTCTTTGTTTCTCTCTGTGTATGTCTCTCTCTCTCTCCCCCTTTCTCTATCTCAGTGATCTATCTCTATCCATCTTTATTTCTGTCTGTCCCTTGCTTTCTCTACCTTTTCTATCTATTTCACCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCTCTCTCTCTTTTCTCTCTTACTCCCATCTTTCTCTGTCTGTCTCCCTCTGCCTTTCTCTCTATCTATCTCTCTTTTACCTCTTCAACCAATCACAGCTGCATAGTGAAAATATAAGGGGCTTTAATATTGAACGCTTCACAAGTATTTGTACGATTTCAATTATATATATTTATTTAACAAGTCTTCAAAAATTCAGTATAAATAAGAGTTTGATAATTCGTCAGCATTTTCATGCACCTTTCACTGGCTTTCAGTCTCTTGTATCTGAATTTTTAGACACAATCCATGCTGCTGTCTCTGGTAAGATATGCATTTCTGTCCAAGGAAAGACATTGATGACTATTATCAATATATTTACACAAGCAATATTTTAAAAACAAATTCTACACCTCGGCGACCACATTGATGTCTTCTTCATTGATTGCGACCACTTCAAGTGGTGAAGATGTCGTTACGCTTTCCGTCGTTGGATGCTCCTTCTCCTCACTTTCATTCTCACCCCATCGTCCTCGGTTACCATAGGGCCGACGATGGCCATCACGCCTGGGAGATCCTTCTTCGGTTCCGTTGCGTCTGTCGAAGGGACGGCCTCCGAAAGGCTTTCTACCGAAGGGGTTGAACCGGAAGGGCCTCATCTCGAACATTGGTCTGTCCTGATCTCCATCTCTGGTCTTGTTGTGATGACGATGGGGGTGGTCTCCCGTCTCATTATGACCCTGGTGACCTTCTGTATGGTTGCGTCTTCCGAAGGGACGGTCTCCGAAAGGCTTTCTACCGAAGTGGTTGTACCGGAAGGGCCTTGTATCATGTAGTTTGTCCTGATCTTGATCTCCCGTCTCATTATGACCTTGGTGACCTTCTGTGTGGTTATGATGACGGTGGTGGTGGCCATGGTGGCGATGGTGGTGAGGGTGAGGACGGCCATCCTCCTCGCTGCTTTCGTTGCGCTGACCAAACGGTTGTTCCTCTGCTTGGTCCTGAGGATGACCTTGACGGTGACCATGATGACGACGTCCAGGACCATCAAACTGACCGGGCCCTCCTAGACCATCACCAATTTGTTGGGCAGCATCAGTTTCTTCTTCTCCATCACCACGCCTGCCTCCTTGGCCGAAGAAAGGTCTTCCTCCAGCACCATCTGGTCTGGAGCCACCAAATCCAGGTCCGTCGAATCTCCTTCCACCCATCGGACCGCCATTTTGTCTCCGTCCATCCATCTCCGGGGCACCAAATCCAGGTCCATCGAACCTCCTTCCACCCATTGGTCCACCATCTTGTCTCCGTCCATCCATTTGTGGGGCACCAGAGTCAGGTCCATCGAACCTTCTTCCACCCATTGGTCCACCATCTTGCCTCGATCCACCCATCTGCATTCCACCCGGCCTTCCTCCAAAGCGACCTTGTCCTCTCTCTCTGCCATTCTTATTTCCTCGTAGTTCATTGTAATCTCTTTGTGCGTGAGCTGTAGGGGATAATGAAGAAAAAATCGAATTAATTAAGTGATCACATTCTGCATTATTATCTTTAGCTCTACATTGGGTTATGGCAGGTGACAAATAAGAATGGTAACTCGCCTTCTTTGATGTTTTTTCCCTTTGTGTTTAACCCTATCGGTTCGATATTCAAAACGCCTAATTCTGACTGAATTGAACTTGAAAACCAGATTGAATATAAAGATAATTCTTATCTTTTGCCACTCGCCCAACGGATTGGTGTAGGCTTAAGAAATAATATAAATTATATTTTGTAACGAACAATTTAGAAATGCATATTATAAAATATGAAATAATCATATATACTTCTGTGAGCTATTCGTTGGCTCTATATTTAGCACTTATCAAGTAATACCGAGTAATAATTTGATTTCTTACCTGAGATAGCAAGAGCAGCCACAATGGCAACGATCAGTGTCACTTTCACCATGTTAGTAATAGGTCTCTCCGATGCTATAGCTTTCTCTAGATTCGTTGCCTTCTAAGAGAGAACGAGCTCCAAACTGAATAACTATCTGCTGGATCACTGAATTTATAGGCTTTCTATCATAGATTGAAATCACTTTCGTACCAGACCGTGTCAGGAATTACCAGGGATACCCTGGTCCAGTTGATCTCCCCCCTTTTTATCTTTATTTTCATACTTTGTTAATATCTTTAACCTTTTATCAACCACTAATTTGGAGAGTGCGTTGTACGTACTAGTACCAAAACCAATCACTTCATCTTCGGATATCCGGTAGAGCCATGTATTGGGTGACACCGATGTCGCGGCGTAGTACAGTAGTCACCCTTTGAGTTTGCGAGGGAGCTAACGGTCATCGGTTTCTCTCCCTCTTTCTCTGTCTGTCTGCCTGCCTGTCTGTCCGTCTGAGTATCTCTCTCTCTATCTCTCTCTATCTCTCCTTCTCCCTCTCTCCCCCGATCCTTCTATCTGAAAAATTGCATTGATTCGAAAGCCATTTAACAAAGTTATCAAAGAATCTAGGCAATAACAACATCATCAAAACAATCATCATCAATTTTCTAATCATCATTTTCATTATCATCACTAGTGTTATTATCTTTTTATCCTTCATCGTGCAGGCATCATCATCATCATCAACGCAATCGATTAATTATATTCAAGTGATTTTTTTTCCAAATGATTATTCCTTTTTTATGATTTCATAACTCGAAGCAAGAGGAATTTCATAACACAACATTGAAGCTCATATTTCTACTAAATAGGCCTACTGTTATATGGTGATACTGCGAACAAATGGAAAGTTGAAAACGATTTCATATGACGTAGTAAAACTAGATCTAGAAAAAGGTCACTTCATTCTTTCTATTTCGGAAATTAAAAAGTCCTTCAGGACATCCGTTGAATCAGCTCATATAGTTCGTATCAGGTCATACCCCGGTTACAATTACAATAATTGCATGTTTATATCCACATTCTGAAGTTAACCTAATGGTATAGGCAGGGGTGGCGATCCCAGGGGGACGGGGGGACACGTCCCTCTTTAATATTTTTAGGGGGATCGTCCCCCCCCCCCCCAGAAAATTTGAAAAAGTGCACACCAAAACAAAATGTATATGGGAAATACTGACTGCCAATACTGCAACACACTTCTAGGCTCTGGGGGCTCAAGTGTGCAGCGTTTAGACTAATCAAAATGCAAAAATCATCTCGCTCGGTCTCTATTCTCCCTCTTATAATATCCTTCAAAATGTACAAGTAAATATTGAAGAAAATCTGTAATCCGTTGTCACCATGTCAGTTTACACTGTTTGTTTACAAAGTGAAGAGTTATAGAAAAAGATCAGTGCTACAAAAATGAATATTAATCCGCTTGCTCTTTTCGGTAAGGAGTCACTACAACATTTATATATTTGCCAGAATTATATTTGACATTTCGATATCAATATACACGTAAAGGGCAGAGGCCTAGAGTGGAAATAGAGATCCAATTCGTGCACAAACTCTATCCTACTTACTAAAGTTTCCCTACTATACTGATATTCACAACCCTTCCAGTTTCATAAATGAGGTATCAAAATATGCTCATCTGACCTTAAATACCTATAAAACCCCTGAGCTTGCGGGGGTTACGCCCCCTGGATGCTCATCTGACCGTAATTAAATGCCTAAAACCCCTGAACTTCCGGGGGCTCTGCCCCTGGACCCCACTTAGGGCCCTTAGGCGGGCCCCTGAATGCTCATTTGACTGTAATTTAAAGCCTAAACCCCTGAGATTAAGGGGGCTCGCTACGCTCTACCTGATCATTGATACTTTAGACCCCCCCCCTCCCCAACGTTCCGCGGGGCATGCATGGGACATTATAAGAGTGGTGGTGACGCGGATTTTTTTTCTTCTGCCCCCTCCCAAACGCTTTTGCTCATAACGCCACTGGTCTCGCGCATTACATCCGGGTAAGAGAGCCTTTAAAAAACGGAAAATCCATTGTATTTCGTACCTGGACGGTATATGTAAATCTAGCAAGAGACTAGCATTTGCCTTTCGCTTGGCTAATTGCCTAAATACATGTATTGGGCTAATTCAACGAACTAAAGCAAAAGCTTGACGTGTTCTTGCTGGAAATGGCTTCCCCAGACAAGCAATAAGCGACGTAGAAAAAGGGAGGCATTGGGACACGTCCCCCGCCCAACCGAAAGCAAAAAGCAACAACAAATAAACAAATAAATTTACAAAACACAAAGTAAAATTATTTCGATAGAAAAGGGGAGAGAGAGAGAGAGCTCTAAGATGACGAAAAAGGAAACTACCCGACGGTTGCCTTGTTAATTTGAATTTCATTTCCAGGACACTTAAGGTAGAAAAAGAGATAGTTAAGAAATAGTAGTTTTTATAGTAGTAATCTAGCGTCAGTAGAAGTGGTAGCAGGAGCAATACAGTGCGTCCCAGAAAAATACGAAACCGAGAGTTATTGATGTTTTATCATAACTTAGTCACATTTATAATTAATAAATGACACATATTTGGAAAGCTTAGATCCTCCTCTTTCATTTGATGCAACTCATTTAATGCACATTTCAGCTGCCCGCCGTAGCAACAAACGGAATTAACAAAAGACTAAAACTCCGTTTCGTTGACAATCAGCCGTAGACGAAAGACTTCATGCATGGTTGATTGTCAACGAAACGGAGTTAAATCTTTTGTCAGTTCTGCTTGTTGCTACGGCAGGCAGCCAATGAAAACGAATTCGTTTGATAAAATTATGAAAATGCAGGCACTACTTTAAACAAACAGAACTTTGTTATTCCTAGCTCACTTTTCCTGACTGATGTGTCATGTGAAAGGGCAGAAACTAAACTTTCTAGAAATGTGATTTTCTCTTTGAAATTCAGAAACCGTCCGCCAAATGACCTTTTTTTAAACTTTGTTAAATGGCTTTCGAATCCATGCAATTTTTCAGATAGAAGGATAGGGGGGTACAAAAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAAAGAGACCAGTTACCGGTGCTTCCTACTGTACTACACCACGACATCAGTGCCACCCAATACATGGCTCTACCGGATATCCGAAGATGATGTAATTGTTTTTACGTACTGGTACAACACTCTCCAAAACAGTGGTTGCTAAGTCTAAGTATAGGATAAAGGTTAAACATATCAACATTGATATTGAAGAAAGAAAAAAAAGAGAAAAAAACGAAAAATAAACGGAAAAAACTAGACCAGGGTAAACCTGATAATTCCTGACACGGTCTGGTACGAAAGTGATTTCAATCTTTGGTAGAAAGCCTATAAATTCAGTGATCCAGCAGATAGTTGATCAGTTTGGAGCTCGTTCTCTTATAGAAGGCTACGAATCTAGAGAAAGCTTGTAGCATCGGAGATACCTTACAAACATGGAGGTGAAAGTGACACTGATCGTTGCCATTGTGGCTGCTCTTGCTATCTCGGGTAAGAAATCAAATTATTACTCGGTATTCCTTCATAAGTGTTAAATATTAAGCCAACAAATGACTCACAGTAGTATATTATTATTTTGATTTATTATAAAAGGTGTTTCTAACTTGTTTGTAACACAATAAAAATAACATTTATTCTTCGGCCTGCAGCATTCTGTTTTTTTTTTATGAAAAAAATGTTTCATGGTTCTTTACAATCTGGTTTTCATATTCAATTCGTTTAGAATTAGGCGTTTTGAATATCCAACCGCATGCATGCATTCTGGTAGAGTTAAACATAACGGGACCAGACATCGAAGAAGACAAATCTCCTAGCATAAACCAATGTAGAGCTAAAGATAATAATGCAGAATGTGATTAATTTTATTAATAAATTCGACTATTTCATTATCCCAACAGCTCACGCACAAAGAGATTTCAATGAACGACGAGGAAAGGAGAATGACACAGAGAGAGGACAAGGTGGCTTTGGAGGAAGGCCTGGTGGAATGCAGATGGGTGGTCCTAGGCAAGATGGTGGACCAATGGGTGGAAGGAGGTTCGATGGACCTGAATCTGGTGCCCCACAAATGGAAGGACGCAGACAAAATGGCGGTCCGATGGGTGGTAGGAGATTCGACGGACCTCGATTTGGTGGCTCCAGACCAGATGGTGCTGGAGGGAGACCTTTCTTCGGCCAAGGAGGCAGGCGTGGTGATGGAGAAGAAGAAACTGATGCTGCCCAACAAATTGGTGATGGTCTAGGAGGGCGCGGTCAGTTTGATGGTCATGGACGTGGACATCATGGTCACCGTCAAGGTCCTCCTCAGGACCGACCAGAGGAACAACCGTTCGGTCAGCGCAACGAAAGCAGCGATGAGGATGGCCGTCCTCACCCTCGCCACCATGGCCGCCACCACCAGCATCATCATCGCAACCACACAGAAGGTCACCAAGGTCACAATGAGACAGGAGATCACCCCCACCGTCATCACAACAAGACCGGAGATGGAGATCAGGACAGACCAATGTTTGAGATGAGGCCCTTCCGGTTCAACCCCTTCGGTAGAAAGCCTTTCGGAGACCGTCCCTTCGACAGACGCAACGGAACCGAAGAAGGATCTCCCAGGCGTGATGGCCAACGTCGGCCCTATGGTAACCGAGGACGTTGGGGTGAGAATGAAAGTGAGGAGAAGGAGCATCCAACGACGGAAAGCGTAACGACATCTTCACCACCTTAAGTGGTCGAGATCGCAGTCAATGAAGAAGACATCAATGTGGTCGCCGAGGTATAGAATTTGTTTAAACAAAAATTGCTTGTGTTAATATACTAATATAGTCACCAATGTCTTTCATTGGACAGAATGCATATCTTTAGTACCAGAGCCTACAACAGAATTTTGTCTAAAAAATCCAGATACAAGAAACTGGAAGCCAGTGAAAGGTGAATGAAATTTTGATAAATTATCAAAATCTAATTTTGTACTGAATTTTCGAAGTCTTGTTAAATAAAATATACAACTGAAATCATACAAATACTTGTGAAGGGTTCTATATTAAAGCCCCTAATATTTTCTTTATGCAGCTGGATTGATCACGATATTGATTGATTGAAGAGAGAAAAGAGAGATAGATAGAGAGAAAGGCAGAGGGAGACAGACAGAGAAAGATGGGAATGAGAGAGAAAGAAAGAGAGAGCAAGAGAGAGAGAGAGGGGGGGGGGGTCAAACAAATAGAAAAGGTAGAGGGAGAGAGAAAGAGAGAAGAAGAAGATAGATAAATAGAGATTATAAATATAAAGAGAGAAAGAGACACAGAGAGAGGACGGGGGGGGGGAGGTGTATGAAAACAGAAAGAGATAGTAATACTAGCAGTAGTATATAGTTGTAGTACTATACTACTGAGCCTACCACCACTTCAATTTCCACTACTACTACTACTACTACTACTACTACTACTACTAGGCTTTTATACTACTACTACTATTACTACTACTACTACTCATAGGCGCCGGAAGTGGGGGGGGGGCAGTTGCCCCCCCCCAGTCAAAAATGTGGGGGGGGGGGCAAAACGCATTTTTGCCCCCCCCCCCCCAAAAAAAAAAAACGCCCCCCCCCCCTCCAAAAAAAACCCCTAAATACAGTAAAGGAGTAAACATGGTTTGTATTTTCAATCCAAAAGAACGTAACAATAATAAAAACCTGAATTAAATCACATATACAATTCCATTCAAAGAAAAAGGAAAGTTCACAGGAATTAAATTTCATAAACATTGCGCATGCCACCTATATGGTATTTATCAATCGAGGTCTCTATAATAGCGATACGCGCATATCGTGGACATATTGTGCGAGAATGGGAAAGCGTGTCCGTTTTTTTGTTATAGGGGCGAGAAGACATGAGCCCCTGAACGCTGGTGTACTGATGGGGGGGGGGGGGTGATGTATTTCTTATTCGAAACAAGTGATTTACAAATGTTGATGTTGTGACATGATTTTCCGGCATTTTTTGTTTTTGTTTTTTGTAAGTCATACCTTTTTATGCGTTTGTTGGAAAATAAGAAATTCCAAAATTACAGTCAGGCGAAATACGCTTATTTAGAAGCCTTTATGTCATGGTCTGCAAAGTGGCTGGGCTCGGGCACCCCACCCCTCTCCTTTTTGAAAAAAAGTATGTTAAAGAGAAAAAGAAAGAAAGACGGAGAAAAAATAAGTGACCTGCCAATGTCACAAATAAGGTATAAAACATGCTCATCTGACCGTAATTAAATGCTTAAAACCCCAGAGCTTACGGGGGCTCCGCCCCCGAACCCCACCAAGGGACCTAAGACGGGCCCCTGGATGCTCATCTGACCTTAATTAAATACCTAAAACCCCTGAGCTTCCGGGGGCTCTGCCCCCTGGACCACACCAAGGGCCCTAAGGCGGGCCCTGGATGCTCATTTGACCGTAATTAAATACCTAAAACCCCTGAGCTTCCGGGGCTCTGCCCCCTGGACCACACCAAGGGCCCTAAGATGGCCCCTGGATGCTCATCTGACTGTAGTTATATATTTAAACCTCTGAGCTTCTTGGGGCTCTCCCCCCTTGGATCAAGTTAATTGACTTACAGAGGGCCCCTGGATGCTTATCTGACCGTAATTAAATACCTAAAACCCCTGAGCTTCCGGGGGCTCAGCCCCTTGACCCCCTGCCGAGGCTCATGCCCTGGACCCCACGCCAATTTACGCTCTACCTGATCGATAATACTCCACTTTGAAAAACGTTCCGCGGGACCTGCATGTAACGTGTAAGACTGGTGGTGATGCAGATTTTTCGTCTACCCCCCCCCCCTTCCGAACTTTTTTCTCACTACGTCACTGCCCCTAGAATGTGAGCCCCCTGGAATGTTTCCCCCCCCCCCCCATCCCAAACTGCTTCCGGCGCGCCTGCTAATACTACTACTACTACTGCTACTACGCTTTTATACTACTACTACTACTATTATATTGCCGCTGCTACTGCTACTACTACTACTGCTATATATTACTACTTAAGTATCTCCGAGGTTGTGGTAAGGGTTAAGCAGTTCCTGTCTTGTTCTTCTTCAGCTCTGCTACTCCTTTTCTATCTAAATTCTGTTACCTCCTGTTTTTGTTTCCTTTTTTTTCTCTTCTTCTTCTTCAACTCTTTAATTTAAAAAATAATGTTTTGGCTTTCGATTGGCGGAGGAGGTGTCCCGTCGATTCCCATGCCTCCCCATTTACTCGACTAATTTCTTGTCTGGGGAGGCCATTTCCAGCAAGAACACAAAGTTTTGCTTCTTTTTGTAAGAAATTTTAGTTCATTGAATTAGATCAAGGTTTAGGCCAAAGTTTTTCAACTTTTTTTTTAAAGTCAAGGCACCCTTTAAAAAAAAAAAACAAGGTTTCGCATCACCCTAATCCCAAATTAATTTACAGAATATTCATTTAACATCACTCTGACACTCGTCCTGCTCCATCACTGTACACATGAGCTCATTTGTTTTTATATTTTGCGAGCGAGCGAGCAAAAAATAAAATAACTCTTTTTAATATGATAATAATTGACTTTATAGTCAACCCACTAAATAAAATATAGAATTAAGCGTGCAGGCACCTCGCTGCCGAATACATAATTACAAAAATCATTACGTGTGGCCAATTCGAAGCACGAATATGAGGGAATTCGGGCATCTCATTGCCCAGAATTATCCAGTTTTTAAATGTTGCGAGCGAGTGAAGAGAACGAGCGTGGTATCAAATAGGCTACTCGGGCACCTCAATGCTCAAATATGGAGGCACTTTGCTGCCAGAAATCATCATGTTTCTAAGTGTTGCGAAGGAGCAAAGTGACCAAGGAAGAAAGACAATTTTCTGTCCAGTAAAATGCTATTTTCATGAGATGACATACTTAAGTTTGATATCTTTATTTATACACGGTTAAAAAAGCCCCAAAAGTTACAAGTCTGATTTCCATTGGGGCCGTATGAAACAATGTAAATACATCGAATTAACATAAAAATGATAATGGTACATCAAAATATGAAATAATCAAGATAAATATCTAAAAAAATAACGATAGAATAGTACTGCCGAAAAAGTATATTTATATGAATAACAATAATCATGAGTGTCCAAACAAGAGTACTGTAAATATACTTCAAATTAAAATTGGTAATAAGAATTGTTACTAGTGCATAAACTGCCAGAAATGATATATATCTATAAAAAAATCAAATGTGGCTGGTCAAGATACTGCATTATTACAGTTAAGGATATGATTACAATTTTATTTTATTTAATTCATTAAAAGAACATTTGAAAGTGAATCAAACTAACAAGCACAACAGATAAAACTCTATTATTTAATCATTTTCGGATAAAATGAAATAAAGCTATATTACATCATATGGAAAGAAGACAAACATTTGTGGTTGTTAAGATTTTCAAGAAATCGACGTAATTCCAATATATTTATTTTGTAATTGTATATATTATTTAAATTCTTTCGTGGCACCTTAGAGATGTCTTGCAGTACATCGATTGAAAAACGCTGGTTTAGGCAATTAGCCAAGGGAAAGGCAAATGCTAGGCTCTTGCTAGATTTACATATACCGTCCATGTAAAAAGTATTATTGATTTTTCAGTTTTCCGAAGGCTCGCTACCCCAGAGGTTTATTCATCACGACCCTTTGATAAATAGATATTCAAAATAATAAATTTGATACTGGAAAACAAAAACTAAATGCTGTTCTGACACAGAAATGTTTTGTCCAATATAGTCAAACACTCAAACAGACTACCTGCCAAAGAGCAAAGGTATGTAACATATCAAATTGTAATTGTGGGAGACGAAATAATTTTCAAGGAACGCAATTACAATTCATTCATATTGCATTATATACCATTAGCTTAACTTTTGAATGTGGATATAAACAAGCAATTATTGTAATTGTAACTGGTATCACATGATACGAGCTATAGGGGCTGATTCAACGGATGTCCTGAATTACTTTTTTAATTTCCGAAATAGAAAGAATGAAGTTACCTTTGTTTAAATCTAGTTTTAAAACGTCATATCAAAACATTTGTAACTTTCCATTTGTTCGCAAAATTTCCATAACAGTTGGCCTATTACGTACAAAATATGAGCTGCAATGTTGTGTTACGAAATTCCTCTTGCTCCGAGTTATGAAATCAAATAAAAACGAAATAAATTTTGAAAAGAAATCCCTCGAATAATGACCATCTATATGAATCGATTGCATTGATGATGATGATGATGATGATCAGGGGCGGCCGAGTGATTTACAAAGTTGGGGGGGGGGGGGCACCAACAAAAAGGGGCACTTTCTAGAGAAAAAAAGGGCACCCCTACAATGGGAAATCTCAAAGCAAAAATATACACAATTTTTAGACATTGGTATATACCCCTACATTGTGATTACATTATCAGGGATGATTTCGATATTTGTTTCTCTGTATACATTATACAGTATATTGCTTAAGTATTGTACTTTGCAGTTGGGTGTGAGGTCGCAGTGCGAAAAATTACATCTTATAAAGAAGAAGAACAAATTCTGATGGGGTTATAAGCACATTTTCATAACAGAAGACTGAAATGACCTTTGATAAGTAACATATTTATATCATTTATAAATGCGAGAGAGCGTTTAATCAAAAGTGAAAAGGGGCATTTCTCGTACCTGAAACGGGGCACTTACTTGAGGTTAATAAAGGCACTTATGAGAATGGAAAAATTGACAATAATTGCAAAGGGAAACAGGAAAAACTGTCGAAGGAAAAGGGGCACGTGTCCAAAAAGGGGCACTTATCTGAGGTGGAAAGGGAGAGGGGCATGTTTATAATGGAATAGGGGCACTTTTCAAAGTAGAAGGGGCACTTCTTACGAGGTTCAAGGGGGACTTTTCGTATGTAAAAAGGGGCACTTTTGGGATACTTGAAAAAGTGGGGGGGGGGGCACTATGCCCACCCCCGCCCCCAGGAGGGCCGCCTCTGATGATGATGATGCCTGCATGATGAAGGAGAAAAAGATAATGAGATTAGTAGTGATGATGATAATGATGATGATAATGGTAATGGTAATGATTGTTTTAATAATGTTTTTAATGCCTAGATTCTTTGATAACTTTGTTAAATGGCTTTCGAATCCATGCAATTTTCAGATAAAAGGAGAGGAGAGAGAGAGAGAGAGACAGGCAGGCAGAGAAAGAGAGAGAGAAACCGATGACCGTTAGCTACCTCACAAATTCCTAGGGTGATTGCCAGGGGCGGCGATTTCTTTTCATGACCGGGGGGGACGAAATGCGAGGGACGGCGGCGTATAATGATCAAAAACGTTTTTTTTTTTTTTTTTTTTTTTTGGGGGGGGGGGGGGGGGAGAAAATCCGCAACCCCACTCTTACATGGTACATGCAGGCCCTGCGGAACGTTTTTCAAAGTATGGGGGGGGGGCTTCGATCAGGTAGAGCAAAGCGAGCGAAGCAAGTGGAGCTTAAATTGGCGTGGGCTCAGCTCAGGGTTTTTAGGCATTTATTAGGGAAAACCATGCCATTTCAGAAACATTTGTAAATCACTGGTATCGAGTTAGAAAAAAATCAAGTTTGAACTTTATTAAGGGGCAACTACCCCCAATCCCCCCCCCCCCCCATCATTACGCCAGGGCGAGGGAGCATAGTGAACGAGAGGGGTGAAGGTGACGGAAGTGACTACCCCCCCCCCCTCCCACCGCAGGTTTTTGAAGTTTTGTTGTATTAACAAAATATAAAAACAAGCAATATATCTTTTTCACACTTCACTTTTCAAGAATATTTACTGTACACTTTGAAGAATATTATGCGAGGGACATAGCTCCCGAGCGAGAAGATTATTGCATTTTTATTTGTCTAAACGCTGCACTCTTAGCAACGACTTAAACTTTAAAAAAGTCTTTGGGTAATAAACAGAACCATTAACAACCTTTTTAACTTAACACTTATAAATTTGCATATTGCGCATAATTTATCAAATTACCAAATTAATTACATATTACTTTCCAAAACAAAGTCACATCCTTACAATATAACATAAAGTGAAAAGTTGAGTCAACTTGTCCACAAGAGTTGCATAAATTATTCACAACTTGCCATTAATATAAGTTTTCTTTTGAGGCAACAAACCTGTGAATCATCTTGAAATTAAATTGTTTAACTTTATTATTACGAATTTGCTTTAATTAAATGAAAATACATCCTTCCAAACAAAGTCATTATCTCAATCTAAAAAGGAATTCCAAAAATAAATGAAATTTGGTTCTCTTGACTTAATAACAAACGATAGTAATCTTTCACTTTCATAACAAAAACATTCACTTTATCCCCTGTTTCTATTTCTAAAAGATTCGAAATATCACATTCATGTTCAAAATCATTATCATAGCTTAATCTATATAACCAATACATTAATTATGATGATGATAATGGGGATGATTATGATTGTTATAATGATTGCCCAGATTTTTTTGACAACTTTCTTAATGGCTTTCGAATCAATGTAATTTTGTTTAGAAAGCGGATGAGAGGGAGAGAGAGAGAGAGAGAGAAAGAGAGAGAGAGAGAGAGATAGAGAGAGAATATCGTTGACCGTTGCTTCCTTGAAAATTCCAAGGGTGACTACCCGATATCAGTGTCACCCAATACTTGGCTCTACCGGATATCCAAAGATGATGTAATTGGTTATACGTCCTGGTACAAAAAGGTTACAAATATTAACGAGGTTTGACATCGAAAAAACAGCAACAACAAAATAAAAACAATGATCAACTGGAACAGGGTATACCTGGTAATTCCTGACACGGTCTGGTACGAAAGTGATTTCAAGCTATGGTAGAAAGCCTATAAATTCAGTGATCCAACAGATAGTTGTTCAGTTTGGAGCTCGTTCTCTTATAGAATGCTACGAACCTATAGAAAGCTATAGCATCGGAGAGACCTATTACTATCATGGTGAAAGTGACACTGATCGTTGCCATTGTGGCTGCTCTTGCTATCTCGGGTAAGAAATCAAATTATTACTCGGTATTCCTTCATAAGTGGTATATTGAGCCAACAAAATTACTCACATAAGTATATTGTTATTTTGATTTATTATAATATGTGTTTCTAACTTGTTTGTGACACAATAAAAAATAACATTTATTCTGCGGCCTGCAGCATTCTGGTTTTTTTAATGAAAAAAATGTTTCATGGTACTTTACAATCTGGTTTTCAAATTCAATTCGGTTAAAATTAGGCGTTTTGAATATCCAACCGCATGCATGCATTCTGGTAGAGTTAAACATAACGGGACCAGACATCGAAGAAGACAAATCTCCTAGCATAAACCAATGTAGAGCTAAAGATAATAATGCAGAATGTGATTAATTTTATTAATAAATTCGACTATTTCATTATCCCAACAGCTCACGCACGAAGAGATTTCAATGAACGACGAGGAAAGGAGAATGGCACAGAGAGAGGACAAGGTGGCTTTGGAGGAAGGCCTGGTGGAATGCAGACGGGTAGTCCTAGGCAAGATGGTGGAAGGAGGTTCGATGGACCTGAATCTGGTGCCCCACAAATGGATGGACGCAGACAAAATGGCGGTCCGATGGGTGGTAGGAGATTCGACGGACCTCGATTTGGTGGCTCCAGACCAGATGGTGCTGGAGGGAGACCTTTCTTCGGCCAAGGAGGCAGGCGTGGTGATGGAGAAGAAGAAACTGATGCTGCCCAACAAATTGGTGATGGTCTAGGAGGGTCCGGTCAGTTTGATGGTCCTAGACGTGGTCATCATGGTCACCGTCAAGGTCCTCCTCAGGACCGACCAGAGGAACAACCGTTCGGTCAGCGCAACGAAAGCAGCGATGAGGATGGCCGTCCTCACCCTCGCCACCATGGCCGCCACCACCAGCATCATCATCGCAACCACACAGAAGGTCACCAAGGTCACAATGAGACAGGAGATCACCCCCACCGTCATCACAACAAGACCGGAGATGGAGATCAGGACAGACCAATGTTTGAGATGAGGCCCTTCCGGTTCAACCCCTTCGGTAGAAAGCCTTTCGGAGACCGTCCCTTCGGCAGACGCAACGGAACCGAGGAAGGATCTCCCAGGCGTGATGGCCAACGTCGGCCCTATGGTAACCGAGGACGTTGGGGTGAGAATGAAAGTGAGGAGAAGGAGCATCCAACGACGGAAAGCGTAACGACATCTTCACCACCTTAAGTGGTCGAGATCGCGATCAATGAAGTCGCCGAGGTGTAGAATTTGTTTTTAAAATATTGCCTGTGTAAATATACTAATAATAGTCACCAATGTCTTTCCTTGGACATAAGCATATATTACCAGAGACTACAATAATGTCATACAATTCAGATACAAGAGACTGAAAGCCAGTGAAAGGTGCATGAAAATGCTGACGAATTATTAAAATCTAATTTTATACTGAATTTTTGAAGACTCGTTAAATAAAAGTATATAACTGAACTCATACAAACACTTGTGAAGCGTTCAATATTATAGCCTCTAATAATGATTATTATTTTCCTTCTGCAGCTGTATTGACCATGATATTGATCTATTGAGATTAGAGAGAGAGAGAGAGAGAGAGAGAGAGATAATATATCAAATAATAGAGAAAGAGAAGGAAATGAGAAGCGAGGAGAAGAGGAAAAATATTGTTACCTATGGCCAGGGTTCGCAAAAGTGAAATACTTCACTGTTGCCCAGAGGCACGCGATGATATTGAGACATTGAGAGAGAAAGAGAGAGAGAGAGAGAGAGGGAGAGTGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAAAGAAAGGGAGGGGGAGTGAGAAAGTGAGAGTGAGGGAGTATTATATATACAGTGCGTCCCAGAAAAAACGAAACCGAGAATTATCGATGTTTTATCATAACTTAAGCACAACTATAATTGATAAATGACACATATCTGGAAAGCTTGGATCCTCCTCCTTCATCTGATGCAACTTATATAATGCATATTTGACGCATGAGTGATTAAAAGCAATTTGAAGAGAGGAAACCAAAAAGTCATTTGGCGGGCGATATCTGAATTTCAAAGAGAAAATGCTATTTCTAGAAAATTGAGTTTCTGCGCTTTCATATGACACCTCAATCAGGAAAATGAGCTTGGAATAACAAAGTTCTGTTTGGTTAAAGTAGTGCTTGCATTTCCATAATTGTATTAAAACGAATTCCGCGGATCCTTCTATAGTGTCACCTAAATGTCGACGGCCAGGCGGCCGCCAGGCCTACCCACTAGTCAATTCGGGAGGATCGAAACGGCAGATCGCAAAAAACAGTACATACAGAAGGAGACATGAACATGAACATCAAAAAAATTGTAAAACAAGCCACAGTTCTGACTTTTACGACTGCACTTCTGGCAGGAGGAGCGACTCAAGCCTTCGCGAAAGAAAATAACCAAAAAGCATACAAAGAAACGTACGGCGTCTCTCATATTACACGCCATGATATGCTGCAGATCCCTAAACAGCAGCAAAACGAAAAATACCAAGTGCCTCAATTCGATCAATCAACGATTAAAAATATTGAGTCTGCAAAAGGACTTGATGTGTGGGACAGCTGGCCGCTGCAAAACGCTGACGGAACAGTAGCTGAATACAACGGCTATCACGTTGTGTTTGCTCTTGCGGGAAGCCCGAAAGACGCTGATGACACATCAATCTACATGTTTTATCAAAAGGTCGGCGACAACTCAATCGACAGCTGGAAAAACGCGGGCCGTGTCTTTAAAGACAGCGATAAGTTCGACGCCAACGATCCGATCCTGAAAGATCAGACGCAAGAATGGTCCGGTTCTGCAACCTTTACATCTGACGGAAAAATCCGTTTATTCTACACTGACTATTCCGGTAAACATTACGGCAAACAAAGCCTGACAACAGCGCAGGTAAATGTGTCAAAATCTGATGACACACTCAAAATCAACGGAGTGGAAGATCACAAAACGATTTTTGACGGAGACGGAAAAACATATCAGAACGTTCAGCAGTTTATCGATGAAGGCAATTATACATCCGGCGACAACCATACGCTGAGAGACCCTCACTACGTTGAAGACAAAGGCCATAAATACCTTGTATTCGAAGCCAACACGGGAACAGAAAACGGATACCAAGGCGAAGAATCTTTATTTAACAAAGCGTACTACGGCGGCGGCACGAACTTCTTCCGTAAAGAAAGCCAGAAGCTTCAGCAGAGCGCTAAAAAACGCGATGCTGAGTTAGCGAACGGCGCCCTCGGTATCATAGAGTTAAATAATGATTACACATTGAAAAAAGTAATGAAGCCGCTGATCACTTCAAACACGGTAACTGATGAAATCGAGCGCGCGAATGTTTTCAAAATGAACGGCAAATGGTACTTGTTCACTGATTCACGCGGTTCAAAAATGACGATCGATGGTATTAACTCAAACGATATTTACATGCTTGGTTATGTATCAAACTCTTTAACCGGCCCTTACAAGCCGCTGAACAAAACAGGGCTTGTGCTGCAAATGGGTCTTGATCCAAACGATGTGACATTCACTTACTCTCACTTCGCAGTGCCGCAAGCCAAAGGCAACAATGTGGTTATCACAAGCTACATGACAAACAGAGGCTTCTTCGAGGATAAAAAGGCAACATTTGCGCCAAGCTTCTTAATGAACATCAAAGGCAATAAAACATCCGTTGTCAAAAACAGCATCCTGGAGCAAGGACAGCTGACAGTCAACTAATAACAGCAAAAAGAAAATGCCGATACTTCATTGGCATTTTCTTTTATTTCTCAACAAGATGGTGAATTGACTAGTGGGTAGATCCACAGGACGGGTGTGGTCGCCATGATCGCGTAGTCGATAGTGGCTCCAAGTAGCGAAGCGAGCAGGACTGGGCGGCGGCCAAAGCGGTCGGACAGTGCTCCGAGAACGGGTGCGCATAGAAATTGCATCAACGCATATAGCGCTAGCAGCACGCCATAGTGACTGGCGATGCTGTCGGAATGGACGATATCCCGCAAGAGGCCCGGCAGTACCGGCATAACCAAGCCTATGCCTACAGCATCCAGGGTGACGGTGCCGAGGATGACGATGAGCGCATTGTTAGATTTCATACACGGTGCCTGACTGCGTTAGCAATTTAACTGTGATAAACTACCGCATTAAAGCTTATCGATGATAAGCTGTCAAACATGAGAATTGATCCGGAACCCTTAATATAACTTCGTATAATGTATGCTATACGAAGTTATTAGGTCCCTCGACTATAGGGTCACCGTCGACAGCGACACACTTGCATCGGATGCAGCCCGGTTAACGTGCCGGCACGGCCTGGGTAACCAGGTATTTTGTCCACATAACCGTGCGCAAAATGTTGTGGATAAGCAGGACACAGCAGCAATCCACAGCAGGCATACAACCGCACACCGAGGTTACTCCGTTCTACAGGTTACGACGACATGTCAATACTTGCCCTTGACAGGCATTGATGGAATCGTAGTCTCACGCTGATAGTCTGATCGACAATACAAGTGGGACCGTGGTCCCAGACCGATAATCAGACCGACAACACGAGTG";
    bwt.mapSequence( mn->seq, mn->ids, mn->coords );
    mn->recoil();
    Node* node = new Node( mn, 0, mn->ids.size()-1, 4 );
    NodeList islands  = { node };
    int32_t dummy[2];
    ExtVars ev( allNodes, islands, dummy, bwt );
    IslandVars iv( ev, 1 );
    node->extendCount_ = 100;
    node->extendIsland( iv, 0 );
    NodeSet currSet = { node };
    bool drxn = 1;
    while ( iv.merged[0].empty() && !currSet.empty() )
    {
        for ( Node* isl : currSet )
        {
            if ( !isl->isContinue( !drxn ) ) continue;
            isl->extendCount_ = 99;
            isl->extendIsland( iv, !drxn );
        }
        currSet.clear();
        for ( Node* node : islands )
        {
            if ( node->isContinue( !drxn ) ) currSet.insert( node );
        }
    }
    
    int iBest = -1;
    int bestTotal = 0;
    for ( int i = 0; i < seqs.size(); i++ )
    {
        if ( olTotals[i] > bestTotal )
        {
            iBest = i;
            bestTotal = olTotals[i];
        }
    }
}

//bool Node::fixSeed( IslandVars &iv, bool drxn )
//{
//    vector<GoodPair> gps, ggps;
//    vector<BadPair> bps;
//    fixSeedGetPairs( iv.ev.bwt, gps, bps, drxn );
//    
//    for ( int i = ends_[0] + 100; i < ends_[1]; i+=100 )
//    {
//        vector<int> dists[2];
//        for ( GoodPair &gp : gps )
//        {
//            if ( gp.coords[0] < i && i < gp.coords[1] ) dists[!gp.isPe].push_back( gp.coords[1] - gp.coords[0] );
//        }
//        int medianDist[2]{0};
//        for ( int j : { 0, 1 } )
//        {
//            sort( dists[j].begin(), dists[j].end() );
//            if ( dists[j].empty() ) continue;
//            medianDist[j] = dists[j][dists[j].size() / 2];
//        }
//        cout << "Coord " << i 
//                << "| PE Count " << dists[0].size() << ", Median " << medianDist[0] 
//                << "| MP Count " << dists[1].size() << ", Median " << medianDist[1] << endl;
//    }
//    
//    for ( GoodPair &gp : gps )
//    {
//        int diff = gp.coords[1] - gp.coords[0];
//        if ( diff < 0 ) continue;
//        if ( gp.isPe && abs( diff - params.maxPeMean ) > 200 ) continue;
//        if ( !gp.isPe && diff - params.maxMpMean > 1000 ) continue;
//        ggps.push_back( gp );
//    }
//    
//    vector<PairPath> paths = fixSeedGraphPairs( bps, drxn );
//    
//    if ( paths.empty() ) return false;
//    
//    NodeList nodes = { this };
//    for ( Node* fwd : getDrxnNodes( !drxn ) ) nodes.push_back( fwd );
//    
//    if ( fixSeedGetNodes( iv, paths, drxn ) ) return true;
//    
//    return fixSeedSetEdge( iv, ggps, drxn );
//}

bool Node::fixSeedGetNodes( IslandVars &iv, vector<PairPath> &paths, bool drxn )
{
    NodeList ends;
    for ( Node* node : iv.ev.island ) if ( node->edges_[drxn].empty() ) ends.push_back( node );
    for ( int i = 0; i < paths.size(); i++ )
    {
        if ( paths[i].olTotal < paths[0].olTotal / 3 ) break;
        for ( int x : { 0, 1 } )
        {
            int coords[2]{-1,-1};
            for ( int j = 0; j < paths[i].path.size(); j++ )
            {
                bool found = false;
                for ( Node* node : iv.ev.island )
                {
                    if ( found ) break;
                    if ( node->reads_.find( paths[i].path[j]->id ) != node->reads_.end() ) found = true;
                    if ( node->seq_.find( paths[i].path[j]->seq ) != node->seq_.npos ) found = true;
                }
                if ( !found && coords[0] == -1 ) coords[0] = j;
                if ( !found ) coords[1] = j;
                if ( found && coords[0] == -1 ) break;
            }
            
            if ( coords[0] == -1 ) break;
            
            MapNode* mn = new MapNode();
            mn->seq = paths[i].path[ coords[0] ]->seq;
            
            for ( int j = coords[0]+1; j < coords[1]; j++ )
            {
                int ol;
                if ( paths[i].path[j-1]->edges[1] == paths[i].path[j] ) ol = paths[i].path[j-1]->ols[1];
                else  ol = paths[i].path[j]->ols[0];
                mn->seq += paths[i].path[j]->seq.substr( ol );
                assert( mn->seq.find( paths[i].path[j]->seq ) != mn->seq.npos );
            }
            
            iv.ev.bwt.mapSequence( mn->seq, mn->ids, mn->coords );
            mn->recoil();
            
            Node* node = new Node( mn, 0, mn->ids.size()-1, drxn+3 );
            iv.ev.island.push_back( node );
            ends.push_back( node );
            node->extendCount_ = 100;
            node->extendIsland( iv, drxn );
            node->extendCount_ = 100;
            node->extendIsland( iv, drxn );
        }
    }
    
    {
        NodeSet fwdSet;
        NodeSet bckSet;
        for ( Node* node : ends )
        {
            node->getDrxnNodes( fwdSet, drxn );
            node->getDrxnNodes( bckSet, !drxn );
        }
        for ( int i = 0; i < ends.size(); )
        {
            fwdSet.erase( ends[i] );
            if ( bckSet.find( ends[i] ) != bckSet.end() ) ends.erase( ends.begin() + i );
            else i++;
        }
        for ( Node* fwd : fwdSet )
        {
            if ( bckSet.find( fwd ) != bckSet.end() ) continue;
            iv.merged[drxn].erase( fwd );
            fwd->clearEdges( !drxn );
            fwd->dismantleNode();
            delete fwd;
            iv.ev.island.erase( remove( iv.ev.island.begin(), iv.ev.island.end(), fwd ), iv.ev.island.end() );
        }
    }
    
    NodeSet currSet;
    for ( Node* node : iv.ev.island ) if ( node->isContinue( !drxn ) ) currSet.insert( node );
    while ( !currSet.empty() )
    {
        for ( Node* isl : currSet )
        {
            if ( !isl->isContinue( !drxn ) ) continue;
            isl->extendCount_ = 99;
            isl->extendIsland( iv, !drxn );
            int pairCount = 0, readCount = 0;
            for ( Node* bck : isl->getDrxnNodes( !drxn, true, true ) )
            {
                readCount += bck->reads_.size();
                for ( ReadMark &mark : isl->marks_[drxn] )
                {
                    for ( Node* t : iv.ev.nodes )
                    {
                        auto it = t->reads_.find( mark.id );
                        if ( it == t->reads_.end() ) continue;
                        if ( abs( it->second[drxn] - ends_[drxn] ) < params.maxMpMean ) pairCount++;
                    }
                }
            }
            if ( pairCount || readCount < 200 ) continue;
//            for ( Node* bck : isl->getDrxnNodes( !drxn, true, true ) )
//            {
//                if ( bck->isContinue( !drxn ) ) bck->stop( 2, !drxn );
//            }
        }
        currSet.clear();
        for ( Node* node : iv.ev.island ) if ( node->isContinue( !drxn ) ) currSet.insert( node );
    }
    
    {
        int minCoord = 0;
        for ( Node* isl : iv.ev.island ) minCoord = min( minCoord, isl->ends_[0] );
        for ( Node* node : ends )
        {
            node->offsetForward( !drxn, true );
        }
        ofstream fp( "/media/glen/ssd/SpBACs/Clone47.fa" );
        for ( Node* mn : iv.ev.nodes )
        {
            fp << ">main" << endl << string( mn->ends_[0] - minCoord, '-' ) + mn->seq_ << endl;
        }
        for ( Node* isl : iv.ev.island )
        {
            fp << ">isl" << endl << string( isl->ends_[0] + ends_[1] - minCoord, '-' ) + isl->seq_ << endl;
        }
        fp.close();
        int x = 0;
    }
    
    NodeList mergeNodes( iv.merged[!drxn].begin(), iv.merged[!drxn].end() );
    for ( Node* merge : mergeNodes )
    {
        NodeList tNodes, qNodes;
        NodeSet bckSet = merge->getDrxnNodes( !drxn );
        int qScore = 0, tScore = 0, qtScore = 0;
        for ( Node* node : iv.ev.nodes ) ( bckSet.find( node ) != bckSet.end() ? tNodes : qNodes ).push_back( node );
        for ( Node* fwd : merge->getDrxnNodes( drxn, true, true ) )
        {
            for ( ReadMark &mark : fwd->marks_[drxn] )
            {
                for ( Node* t : tNodes ) tScore += t->reads_.find( mark.id ) != t->reads_.end();
                for ( Node* q : qNodes ) qtScore += q->reads_.find( mark.id ) != q->reads_.end();
            }
        }
        for ( Node* q : qNodes )
        {
            for ( ReadMark &mark : q->marks_[drxn] )
            {
                for ( Node* t : tNodes ) qScore += t->reads_.find( mark.id ) != t->reads_.end();
            }
        }
        if ( qScore + qtScore > tScore )
        {
//            ofstream fp( "/media/glen/ssd/SpBACs/Clone42.fa" );
//            for ( Node* con : merge->getConnectedNodes( false ) )
//            {
//                string seq = con->seq_;
//                revComp( seq );
//                fp << ">Clone42" << endl << seq << endl;
////                fp << ">Clone42" << endl << string( max( 0, con->ends_[0] ), '-' ) + seq << endl;
//            }
//            fp.close();
            iv.merged[!drxn].erase( merge );
            iv.merged[drxn].erase( merge );
            merge->dismantleNode();
            delete merge;
            iv.ev.island.erase( remove( iv.ev.island.begin(), iv.ev.island.end(), merge ), iv.ev.island.end() );
            ends.erase( remove( ends.begin(), ends.end(), merge ), ends.end() );
        }
    }
    
    assert( iv.merged[drxn].empty() );
    if ( !iv.merged[!drxn].empty() )
    {
        NodeSet fwdSet = iv.merged[!drxn], bckSet;
        for ( Node* merge : iv.merged[!drxn] ) merge->getDrxnNodes( fwdSet, drxn );
        for ( Node* fwd : fwdSet )
        {
            if ( fwd->drxn_ <= 2 ) continue;
            iv.ev.island.erase( remove( iv.ev.island.begin(), iv.ev.island.end(), fwd ), iv.ev.island.end() );
            ends.erase( remove( ends.begin(), ends.end(), fwd ), ends.end() );
            iv.ev.nodes.push_back( fwd );
            fwd->drxn_ = drxn;
            fwd->getDrxnNodes( bckSet, !drxn );
        }
        
        for ( int i = 0; i < iv.ev.island.size(); )
        {
            if ( fwdSet.find( iv.ev.island[i] ) == fwdSet.end() && bckSet.find( iv.ev.island[i] ) != bckSet.end() )
            {
                iv.ev.island[i]->dismantleNode();
                delete iv.ev.island[i];
                iv.ev.island.erase( iv.ev.island.begin() + i );
            }
            else i++;
        }
        
        iv.merged[!drxn].clear();
        
        return true;
    }
    
    NodeIntMap scores;
    for ( Node* node : iv.ev.island )
    {
        int score = 0;
        for ( ReadMark &mark : node->marks_[drxn] )
        {
            for ( Node* t : iv.ev.nodes )
            {
                auto it = t->reads_.find( mark.id );
                if ( it == t->reads_.end() ) continue;
                if ( abs( it->second[drxn] - ends_[drxn] ) > params.maxMpMean + 1500 ) continue;;
                score++;
                break;
            }
        }
        scores[node] = score;
    }
    
    NodeSet goodSet;
    for ( Node* node : ends )
    {
        if ( !node->edges_[drxn].empty() ) continue;
        node->offsetForward( !drxn, true );
        goodSet.insert( node );
        Node* curr = node;
        while ( curr && !curr->edges_[!drxn].empty() && curr->drxn_ > 2 )
        {
            Node* best = NULL;
            int bestScore;
            for ( Node* nxt : curr->getNextNodes( !drxn ) )
            {
                int score = scores[nxt];
                for ( Node* fwd : nxt->getDrxnNodes( !drxn ) ) score += scores[fwd];
                if ( !best || score > bestScore )
                {
                    best = nxt;
                    bestScore = score;
                }
            }
            if ( best ) goodSet.insert( best );
            curr = best;
        }
    }
    
    for ( int i = 0; i < iv.ev.island.size(); )
    {
        if ( goodSet.find( iv.ev.island[i] ) == goodSet.end() )
        {
            iv.ev.island[i]->dismantleNode();
            delete iv.ev.island[i];
            iv.ev.island.erase( iv.ev.island.begin() + i );
        }
        else i++;
    }
    
    return false;
}

void Node::fixSeedGetPairs( Querier &bwt, vector<GoodPair> &gps, vector<BadPair> &bps, bool drxn )
{
    NodeList tNodes = { this };
    for ( Node* bck : getDrxnNodes( !drxn ) ) tNodes.push_back( bck );
    
    for ( Node* q : tNodes )
    {
        if ( abs( q->ends_[drxn] - ends_[drxn] > params.maxMpMean ) ) continue;
        for ( ReadMark &mark : q->marks_[!drxn] )
        {
            bool found = false;
            for ( Node* t : tNodes )
            {
                auto it = reads_.find( mark.id );
                if ( it != reads_.end() )
                {
                    GoodPair gp( mark.mark, it->second[drxn], drxn, params.isReadPe( mark.id ) );
                    if ( gp.coords[0] < gp.coords[1] && q == this ) gps.push_back( gp );
                    found = true;
                    break;
                }
            }

            if ( found ) continue;
            if ( drxn ? mark.estimate < ends_[1] - 1000 : ends_[0] + 1000 < mark.estimate ) continue;

            BadPair bp;
            bp.id = mark.id;
            bp.ests[!drxn] = mark.mark;
            bp.ests[drxn] = mark.estimate;
            bp.seq = bwt.getSequence( mark.id );
            for ( Node* t : tNodes )
            {
                size_t hit = t->seq_.find( bp.seq );
                if ( hit != t->seq_.npos )
                {
                    GoodPair gp( mark.mark, t->ends_[0] + hit + ( drxn ? bp.seq.length() : 0 ), drxn, params.isReadPe( mark.id ) );
                    if ( gp.coords[0] < gp.coords[1] && q == this ) gps.push_back( gp );
                    found = true;
                    break;
                }
            }

            if ( found || q->drxn_ == 2 ) continue;

            bps.push_back( bp );
        }
    }
}

vector<PairPath> Node::fixSeedGraphPairs( vector<BadPair> &bps, bool drxn )
{
    for ( BadPair &bp1 : bps )
    {
        bp1.ols[1] = params.readLen / 2;
        if ( bp1.redundant ) continue;
        for ( BadPair &bp2 : bps )
        {
            if ( &bp1 == &bp2 ) continue;
            if ( bp2.seq == bp1.seq ) bp2.redundant = true;
            if ( bp2.redundant ) continue;
            int ol = mapSeqOverlap( bp1.seq, bp2.seq, bp1.ols[1] + 1 );
            if ( ol )
            {
                bp1.edges[1] = &bp2;
                bp1.ols[1] = ol;
                if ( !bp2.edges[0] || ol > bp2.ols[0] )
                {
                    bp2.edges[0] = &bp1;
                    bp2.ols[0] = ol;
                }
            }
        }
    }
    
    vector<BadPair*> ends[2];
    for ( BadPair &bp : bps )
    {
        for ( bool d : { 0, 1 } )
        {
            if ( !bp.edges[d] && bp.edges[!d] )
            {
                if ( bp.edges[!d]->edges[d] != &bp || !bp.edges[!d]->edges[!d] )
                {
                    bp.edges[!d] = NULL;
                }
                else
                {
                    ends[d].push_back( &bp );
                }
            }
        }
    }
    
    vector<PairPath> paths;
    unordered_set<BadPair*> used;
    for ( bool d : { 0, 1 } )
    {
        for ( BadPair* bp : ends[d] )
        {
            PairPath path;
            path.path.push_back( bp );
            path.olTotal = 0;
            bool loop = false;
            while ( path.path.back()->edges[!d] && !loop ) 
            {
                path.olTotal += path.path.back()->ols[!d];
                loop = find( path.path.begin(), path.path.end(), path.path.back()->edges[!d] ) != path.path.end();
                path.path.push_back( path.path.back()->edges[!d] );
            }
            if ( loop ) continue;
            if ( d ) reverse( path.path.begin(), path.path.end() );
            if ( path.olTotal < params.readLen * 10 || path.path.size() < 10 ) continue;
            path.path.erase( path.path.begin(), path.path.begin() + 4 );
            path.path.erase( path.path.end() - 4, path.path.end() );
            if ( used.find( path.path[0] ) != used.end() && used.find( path.path.back() ) != used.end() ) continue;
            used.insert( path.path.begin(), path.path.end() );
            
            paths.push_back( path );
        }
    }
    
    sort( paths.begin(), paths.end(), []( PairPath &a, PairPath &b ){
        return a.olTotal > b.olTotal;
    });
    
    return paths;
}

bool Node::fixSeedSetEdge( IslandVars &iv, vector<GoodPair> &gps, bool drxn )
{
    Node* best = NULL;
    NodeList starts;
    for ( Node* node : iv.ev.island )
    {
        if ( !node->edges_[!drxn].empty() && iv.merged[!drxn].find( node ) == iv.merged[!drxn].end() ) continue;
        starts.push_back( node );
        node->offsetForward( drxn );
        vector<int32_t> offsets, hits;
        for ( Node* fwd : node->getDrxnNodes( drxn, true, true ) )
        {
            for ( ReadMark &mark : fwd->marks_[drxn] )
            {
                for ( Node* t : iv.ev.nodes )
                {
                    auto it = t->reads_.find( mark.id );
                    if ( it == t->reads_.end() ) continue;
                    offsets.push_back( it->second[!drxn] - mark.estimate );
                    hits.push_back( it->second[drxn] );
                }
            }
        }
        if ( offsets.size() < 50 ) continue;
        sort( hits.begin(), hits.end() );
        sort( offsets.begin(), offsets.end() );
        int32_t offset = offsets[ offsets.size() / 2 ];
        node->offset( offset );
        node->offsetForward( drxn );
//        if ( 61700 < offset && offset < 61900 ) continue;
        if ( !best || abs( best->ends_[!drxn] - ends_[drxn] ) > abs( node->ends_[!drxn] - ends_[drxn] ) )
        {
            best = node;
        }
        if ( node->ends_[0] < ends_[1] - 500 )
        {
            int i = 0;
            while ( i < hits.size() && hits[i] < node->ends_[0] - params.maxMpMean - 1000 ) i++;
            hits.erase( hits.begin(), hits.begin() + i );
            i = 0;
            while ( i < hits.size() && hits[i] < node->ends_[0] + 100 ) i++;
            hits.erase( hits.begin() + i, hits.end() );
            if ( hits.empty() ) continue;
            int mainHits = 0;
            for ( GoodPair &gp : gps ) if ( gp.coords[0] < hits.back() && hits.back() < gp.coords[1] ) mainHits++;
            if ( node->ends_[0] < ends_[0] ) continue;
            ofstream fp( "/media/glen/ssd/test.fa" );
            fp << ">main" << endl << seq_ << endl << ">alt" << endl << string( node->ends_[0] - ends_[0], '-' ) << node->seq_ << endl;
            fp.close();
            int x = 0;
        }
    }
    
    if ( !best ) return false;
    
    Node* curr = best;
    NodeSet goodSet = { curr }, delSet;
    while ( curr && !curr->edges_[drxn].empty() )
    {
        if ( curr->edges_[drxn].size() > 1 )
        {
            curr->getDrxnNodes( delSet, drxn );
            for ( Node* nxt : curr->getNextNodes( drxn ) )
            {
                nxt->dismantleNode( delSet, drxn );
            }
        }
        else curr = curr->edges_[drxn][0].node;
        goodSet.insert( curr );
    }
    
    NodeList nodes[3];
    for ( int i = 0; i < iv.ev.island.size(); )
    {
        if ( delSet.find( iv.ev.island[i] ) != delSet.end() )
        {
            delete iv.ev.island[i];
            iv.ev.island.erase( iv.ev.island.begin() + i );
        }
        else if ( goodSet.find( iv.ev.island[i] ) != goodSet.end() )
        {
            iv.ev.island[i]->drxn_ = drxn;
            nodes[drxn].push_back( iv.ev.island[i] );
            iv.ev.island.erase( iv.ev.island.begin() + i );
        }
        else if ( iv.merged[0].find( iv.ev.island[i] ) != iv.merged[0].end()
                || iv.merged[1].find( iv.ev.island[i] ) != iv.merged[1].end() )
        {
            assert( false );
            iv.ev.island[i]->dismantleNode();
            delete iv.ev.island[i];
            iv.ev.island.erase( iv.ev.island.begin() + i );
        }
        else i++;
    }
    
    Node::mergeAll( nodes, delSet );
    best = NULL;
    for ( Node* node : nodes[drxn] )
    {
        if ( delSet.find( node ) != delSet.end() )
        {
            node->dismantleNode();
            delete node;
            iv.ev.nodes.erase( remove( iv.ev.nodes.begin(), iv.ev.nodes.end(), node ), iv.ev.nodes.end() );
        }
        else
        {
            assert( !best );
            node->remap( iv.ev.bwt );
            best = node;
        }
    }
    
    Node* edge = NULL;
    nodes[drxn].clear();
    delSet.clear();
    for ( Node* node : iv.ev.nodes ) if ( node->drxn_ != 2 ) nodes[drxn].push_back( node );
    Node::mergeAll( nodes, delSet );
    for ( Node* node : nodes[drxn] )
    {
        if ( delSet.find( node ) != delSet.end() )
        {
            node->dismantleNode();
            delete node;
            iv.ev.nodes.erase( remove( iv.ev.nodes.begin(), iv.ev.nodes.end(), node ), iv.ev.nodes.end() );
        }
        else
        {
            if ( edge )
            {
                NodeSet bckSet = edge->getDrxnNodes( !drxn );
                if ( bckSet.find( node ) != bckSet.end() ) continue;
            }
            edge = node;
        }
    }
    
    int32_t limits[2] = { best->ends_[0], best->ends_[0] };
    for ( auto &read : best->reads_ )
    {
        if ( abs( best->ends_[!drxn] - read.second[drxn] ) > params.readLen + 100 ) continue;
        addRead( read.first
                , edge->ends_[1] + 10 + read.second[0] - best->ends_[0]
                , edge->ends_[1] + 10 + read.second[1] - best->ends_[0]
                , read.second.redundant );
        limits[0] = min( limits[0], read.second[0] );
        limits[1] = max( limits[1], read.second[1] );
    }
    edge->seq_ += string( 10, 'N' ) + best->seq_.substr( 0, limits[1] - limits[0] );
    edge->ends_[1] = edge->ends_[0] + edge->seq_.length();
//    for ( auto &read : best->reads_ )
//    {
//        addRead( read.first
//                , edge->ends_[1] + 10 + read.second[0] - best->ends_[0]
//                , edge->ends_[1] + 10 + read.second[1] - best->ends_[0]
//                , read.second.redundant );
//    }
//    edge->seq_ += string( 10, 'N' ) + best->seq_;
//    edge->ends_[1] = edge->ends_[0] + edge->seq_.length();
    best->setCoverage();
    best->dismantleNode();
    edge->stop_[drxn] = 0;
    delete best;
    iv.merged[0].clear();
    iv.merged[1].clear();
    
    return true;
}

bool Node::isSeed( int32_t seedLen )
{
    return validLimits_[0] < ends_[1] && 0 < ends_[1] && ends_[0] < validLimits_[3] && ends_[0] < seedLen;
}

bool Node::plotSeed( IslandVars &iv, NodeSet &delSet, bool drxn, bool finished )
{
    Node* curr = this;
    Node* base = NULL;
    for ( Node* node : iv.ev.nodes ) if ( node->drxn_ == 2 ) base = node;
    offsetForward( drxn );
    while ( curr )
    {
        int ol = mapSeqOverlap( curr->seq_, base->seq_, 80 );
        if ( ol && curr->drxn_ != 2 )
        {
            curr->trimEnd( curr->ends_[1] - ol, iv.ev.nodes, 1 );
            return true;
        }
        
        int32_t furthest = curr->ends_[drxn];
        int fwdCount = 0;
        for ( Node* fwd : curr->getDrxnNodes( drxn ) )
        {
            fwdCount++;
            furthest = drxn ? max( furthest, fwd->ends_[1] ) : min( furthest, fwd->ends_[0] );
        }
        if ( !finished && abs( curr->ends_[drxn] - furthest ) < 1000 && fwdCount < 15 ) break;
        
        NodeOffsetMap maps[2] = { curr->getDrxnNodesOffset( 0, 0, true )
                                , curr->getDrxnNodesOffset( 1, 0, true ) };
        
        NodeSet sharedSet;
        NodeList nxtNodes;
        NodeSetList fwdSets;
        {
            NodeSet fwdSet;
            for ( Node* nxt : curr->getNextNodes( drxn ) )
            {
                nxtNodes.push_back( nxt );
                NodeSet nxtFwdSet = nxt->getDrxnNodes( drxn, false, true );
                fwdSets.push_back( nxtFwdSet );
                for ( Node* fwd : nxtFwdSet )
                {
                    if ( fwdSet.find( fwd ) != fwdSet.end() ) sharedSet.insert( fwd );
                    else fwdSet.insert( fwd );
                }
            }
        }
        
        bool isOffset = false;
        for ( Node* node : sharedSet )
        {
            for ( Node* prv : node->getNextNodes( !drxn ) )
            {
                if ( sharedSet.find( prv ) != sharedSet.end() ) continue;
                auto it = maps[drxn].find( prv );
                if ( it == maps[drxn].end() || it->second.second - it->second.first < 200 ) continue;
                isOffset = true;
            }
        }
        if ( isOffset ) sharedSet.clear();
        
        NodeList tNodes;
        for ( auto it : maps[!drxn] )
        {
            tNodes.push_back( it.first );
        }
        int bestScores[2];
        int iBest = 0;
        for ( int i = 0; i < nxtNodes.size(); i++ )
        {
            maps[drxn] = nxtNodes[i]->getDrxnNodesOffset( drxn, 0, true );
            maps[!drxn] = nxtNodes[i]->getDrxnNodesOffset( !drxn, 0, true );
            int score = 0;
            int bad = 0;
            int readCount = 0;
            for ( Node* fwd : fwdSets[i] )
            {
                auto itMap = maps[drxn].find( fwd );
                if ( itMap == maps[drxn].end() || sharedSet.find( fwd ) != sharedSet.end() ) continue;
                int fwdOff[2] = { itMap->second.first, itMap->second.second };
                for ( ReadMark &mark : fwd->marks_[drxn] )
                {
                    readCount += ( mark.estimate < curr->ends_[1] );
                    int best = 2000;
                    bool anyHit = false;
                    for ( Node* t : tNodes )
                    {
                        auto it = t->reads_.find( mark.id );
                        if ( it == t->reads_.end() ) continue;
                        int off = mark.estimate - it->second[!drxn];
                        auto itMap = maps[!drxn].find( t );
                        int tOff[2] = { itMap->second.first, itMap->second.second };
                        if ( off > 0 )
                        {
                            off = max( 0, off - ( drxn ? fwdOff[1] + tOff[0] : tOff[1] + fwdOff[0] ) );
                        }
                        else
                        {
                            off = min( 0, off + ( drxn ? fwdOff[0] + tOff[1] : tOff[0] + fwdOff[1] ) );
                        }
                        off = abs( off );
                        if ( !anyHit || off < best ) best = off;
                        anyHit = true;
                    }
                    if ( params.isReadPe( mark.id ) ? best < 200 : best < 1500 ) score++;
                    else bad += anyHit;
                }
            }
            
            if ( !i || score > bestScores[1] || score == bestScores[1] && bad < bestScores[0] )
            {
                iBest = i;
                bestScores[1] = score;
                bestScores[0] = bad;
            }
        }
        for ( int i = 0; i < nxtNodes.size(); i++ )
        {
            if ( i == iBest ) continue;
            nxtNodes[i]->dismantleNode( delSet, drxn );
        }
        curr = nxtNodes.empty() ? NULL : nxtNodes[iBest];
    }
    offsetForward( drxn );
    
    return false;
}

//void Node::plotSeed( NodeList &ends, bool drxn )
//{
//    struct SeedBranch
//    {
//        SeedBranch( Edge &e, NodeList &tNodes, NodeSet &shared, bool drxn )
//        : n( e.node ), ol( e.ol )
//        {
//            score[0] = score[1] = reads = 0;
//            for ( Node* fwd : e.node->getDrxnNodes( drxn, false, true ) )
//            {
//                reads += fwd->reads_.size();
//                for ( ReadMark &mark : fwd->marks_[drxn] )
//                {
//                    for ( Node* t : tNodes )
//                    {
//                        if ( t->reads_.find( mark.id ) == t->reads_.end() ) continue;
//                        score[ shared.find( t ) != shared.end() ]++;
//                    }
//                }
//            }
//        }
//        bool operator>( SeedBranch &rhs )
//        {
//            if ( score[0] > rhs.score[0] ) return true;
//            else if ( score[0] < rhs.score[1] ) return false;
//            else if ( score[1] > rhs.score[1] ) return true;
//            else if ( score[1] < rhs.score[1] ) return false;
//            else if ( ol > rhs.ol ) return true;
//            else if ( ol < rhs.ol ) return false;
//            else if ( reads < rhs.reads ) return false;
//            return true;
//        }
//        Node* n;
//        int ol, score[2], reads;
//    };
//    struct SeedPath
//    {
//        SeedPath( Node* node, bool drxn )
//        : ended( false )
//        {
//            path.push_back( node );
//        }
//        NodeList path;
//        NodeListList alts, starts;
//        NodeSet shared;
//        bool ended;
//    };
//    vector<SeedPath> paths;
//    for ( Node* node : ends ) paths.push_back( SeedPath( node, drxn ) );
//    
//    bool complete = false;
//    while ( !complete )
//    {
//        complete = true;
//        for ( SeedPath &path : paths )
//        {
//            if ( path.ended ) continue;
//            complete = false;
//            NodeSet altFwd;
//            for ( SeedPath &altPath : paths )
//            {
//                if ( &path == &altPath ) continue;
//                altFwd.insert( altPath.path.back() );
//                altPath.path.back()->getDrxnNodes( altFwd, drxn );
//            }
//            NodeList tNodes( path.path.begin(), path.path.end() );
//            NodeList branches;
//            NodeSetList branchFwd;
//            while ( !path.ended && altFwd.find( path.path.back() ) == altFwd.end() )
//            {
//                vector<SeedBranch*> edges;
//                SeedBranch* edge = NULL;
//                for ( Edge &e : path.path.back()->edges_[drxn] )
//                {
//                    SeedBranch* branch = new SeedBranch( e, tNodes, path.shared, drxn );
//                    edges.push_back( branch );
//                    if ( !edge || *branch > *edge ) edge = branch;
//                }
//                if ( !edge ) path.ended = true;
//                else
//                {
//                    for ( int i = 0; i < branches.size(); )
//                    {
//                        if ( branches[i] == edge->n )
//                        {
//                            branches.erase( branches.begin() + i );
//                            branchFwd.erase( branchFwd.begin() + i );
//                        }
//                        else if ( branchFwd[i].find( edge->n ) != branchFwd[i].end() )
//                        {
//                            NodeSet pathSet = edge->n->getDrxnNodesInSet( branchFwd[i], !drxn, true );
//                            NodeList allele;
//                            Node* curr = branches[i];
//                            while ( curr && altFwd.find( curr ) == altFwd.end() )
//                            {
//                                allele.push_back( curr );
//                                SeedBranch* branch = NULL;
//                                for ( Edge &e : curr->edges_[drxn] )
//                                {
//                                    if ( pathSet.find( e.node ) == pathSet.end() || altFwd.find( curr ) != altFwd.end() ) continue;
//                                    SeedBranch* edgeBranch = new SeedBranch( e, tNodes, path.shared, drxn );
//                                    if ( !branch || *edgeBranch > *branch )
//                                    {
//                                        if ( branch ) delete branch;
//                                        branch = edgeBranch;
//                                    }
//                                    else delete edgeBranch;
//                                }
//                                curr = NULL;
//                                if ( branch )
//                                {
//                                    curr = branch->n;
//                                    delete branch;
//                                }
//                            }
//                            for ( Node* node : allele )
//                            {
//                                if ( find( tNodes.begin(), tNodes.end(), node ) == tNodes.end() ) tNodes.push_back( node );
//                            }
//                            path.alts.push_back( allele );
//                            branches.erase( branches.begin() + i );
//                            branchFwd.erase( branchFwd.begin() + i );
//                        }
//                        else i++;
//                    
//                    }
//                    path.path.push_back( edge->n );
//                    bool looped = false;
//                    for ( int i = 0; i < path.path.size()-1; i++ )
//                    {
//                        if ( path.path[i] != edge->n ) continue;
//                        looped = true;
//                        SeedBranch* branch = NULL;
//                        NodeList branchPath;
//                        for ( int j = i; j < path.path.size()-1; j++ )
//                        {
//                            for ( Edge &e: path.path[j]->edges_[drxn] )
//                            {
//                                for ( int k = 0; k < branches.size(); )
//                                {
//                                    if ( e.node == branches[k] )
//                                    {
//                                        branches.erase( branches.begin() + k );
//                                        branchFwd.erase( branchFwd.begin() + k );
//                                    }
//                                    else k++;
//                                }
//                                if ( find( tNodes.begin(), tNodes.end(), e.node ) != tNodes.end() ) continue;
//                                SeedBranch* edgeBranch = new SeedBranch( e, tNodes, path.shared, drxn );
//                                if ( !branch || *edgeBranch > *branch )
//                                {
//                                    if ( branch ) delete branch;
//                                    branch = edgeBranch;
//                                    branchPath = { path.path.begin() + i, path.path.begin() + j };
//                                    branchPath.push_back( branch->n );
//                                }
//                                else delete edgeBranch;
//                            }
//                        }
//                        if ( branch )
//                        {
//                            path.path.insert( path.path.end(), branchPath.begin(), branchPath.end() );
//                            delete branch;
//                        }
//                        else path.ended = true;
//                        break;
//                    }
//                    if ( find( tNodes.begin(), tNodes.end(), edge->n ) == tNodes.end() ) tNodes.push_back( edge->n );
//                    for ( SeedBranch* e : edges )
//                    {
//                        if ( !looped && e != edge && altFwd.find( e->n ) == altFwd.end() )
//                        {
//                            branches.push_back( e->n );
//                            branchFwd.push_back( e->n->getDrxnNodes( drxn, false, true ) );
//                        }
//                        delete e;
//                    }
//                }
//            }
//            
//        }
//    }
//}

void Node::reviewSeed( Querier &bwt, NodeRoll &nodes )
{
//    for ( int i = 0; i < nodes.size(); i++ ) if ( nodes[i]->pruneBad( bwt, nodes ) ) nodes.erase( nodes[i], i );
//    Node::merge( nodes );
//    nodes.test();
//    Node::claimBads( nodes );
//    Node::pruneBlunt( bwt, nodes );
//    Node::merge( nodes );
//    Node::pruneBlunt( bwt, nodes );
//    Node::merge( nodes );
//    Node::pruneEdges( bwt, nodes );
//    Node::prune( bwt, nodes );
//    Node::verify( nodes );
//    nodes.test();
//    Node::pruneLoops( bwt, nodes );
//    assert( false );
}

void Node::seedAdd( ReadStruct &read )
{
    int32_t diff = read.coords[1] - ends_[1];
    if ( diff >= 0 )
    {
        validLimits_[2] = validLimits_[3] = read.tether[1];
        seq_ += read.seq.substr( read.seq.length() - diff );
        ends_[1] += diff;
    }
    else
    {
        assert( false );
    }
    reads_.insert( make_pair( read.readId, Coords( read.coords[0], read.coords[1], diff < 0 ) ) );
}

bool Node::seedCongruent( ReadStruct &read, int32_t &coord )
{
    bool congruent = read.tether[0] == read.coords[0] && validLimits_[0] <= read.tether[0] && read.tether[0] < validLimits_[3];
    bool maybe = read.tether[0] <= validLimits_[0];
    coord = min( read.tether[1], validLimits_[3] );
    
    if ( !congruent && maybe )
    {
        congruent = true;
        int32_t diff = read.coords[0] - ends_[0];
        int32_t len = max( read.tether[0], validLimits_[0] ) - read.coords[0];
        for ( int i( 0 ); i < len; i++ )
        {
            congruent = congruent && seq_[i+diff] == read.seq[i];
        }
    }
    
    while( congruent && coord != ends_[1] && seq_[coord - ends_[0]] == read.seq[coord - read.coords[0]] )
    {
        coord++;
    }
    
    if ( congruent && coord != ends_[1] )
    {
        congruent = false;
        for ( auto &read : reads_ )
        {
            congruent = congruent || read.second[1] <= coord;
        }
    }
    
    return congruent;
}

bool Node::seedDiminutive()
{
    int readCount = 0;
    for ( auto &read : reads_ ) if ( !read.second.redundant 
            && read.second[1] - read.second[0] > params.readLen * 0.8 ) readCount++;
    if ( readCount > 1 ) return false;
    int ols[2] = { getBestOverlap( 0 ), getBestOverlap( 1 ) };
    if ( ols[0] + ols[1] > seq_.length() ) return false;
    if ( ( !ols[0] || !ols[1] ) && ( max( ols[0], ols[1] ) > params.readLen / 2 ) ) return false;
    for ( bool drxn : { 0, 1 } )
    {
        bool better = edges_[drxn].empty();
        for ( Node* nxt : getNextNodes( drxn ) )
        {
            if ( nxt->edges_[!drxn].size() == 1 ) return false;
            for ( Edge &e : nxt->edges_[!drxn] )
            {
                if ( e.ol < params.readLen / 2 || e.ol <= ols[drxn] ) continue;
                int eReadCount = 0;
                for ( auto &read : e.node->reads_ ) if ( !read.second.redundant 
                        && read.second[1] - read.second[0] > params.readLen * 0.8 ) eReadCount++;
                if ( e.ol + e.node->getBestOverlap( !drxn ) > seq_.length() || eReadCount > 5 ) better = true;
            }
        }
        
        if ( !better ) return false;
    }
    
    return true;
}

void Node::seedGetExtend( NodeList* extendNodes, NodeSet &seedSet, NodeSet &delSet, int32_t* limits )
{
    for ( int drxn : { 0, 1 } )
    {
        NodeSet currSet = seedSet;
        NodeIntMap edgeMap;
        
        while( !currSet.empty() )
        {
            NodeSet nxtSet;
            NodeSet currFwd;
            for ( Node* curr : currSet )
            {
                curr->getDrxnNodes( currFwd, drxn );
            }
            
            for ( Node* curr : currSet )
            {
                if ( currFwd.find( curr ) != currFwd.end() )
                {
                    nxtSet.insert( curr );
                }
                else
                {
                    int edgeCount = 8 + curr->edges_[!drxn].size();

                    for ( Node* bck : curr->getNextNodes( !drxn ) )
                    {
                        auto it = edgeMap.find( bck );
                        edgeCount = it != edgeMap.end() ? min( edgeCount, it->second ) : edgeCount;
                    }
                    
                    edgeCount = seedSet.find( curr ) != seedSet.end() ? curr->edges_[!drxn].size() : edgeCount;
                    edgeCount += curr->edges_[drxn].size() - curr->edges_[!drxn].size();
                    
                    if ( edgeCount < 8 && ( drxn ? curr->ends_[1] < limits[1] : limits[0] < curr->ends_[0] ) )
                    {
                        if ( curr->isContinue( drxn ) && !curr->clones_ )
                        {
                            extendNodes[drxn].push_back( curr );
                        }
                        curr->getNextNodes( nxtSet, drxn );
                    }

                    edgeMap[curr] = edgeCount;
                }
            }
            currSet = nxtSet;
        }
    }
}

bool Node::seedJoin( Node* node, int32_t coord, bool drxn )
{
//    for ( bool d : { 0, 1 } )
//    {
//        bool anyOrigin = false;
//        NodeSet bckSet = ( d == drxn ? this : node )->getDrxnNodes( !d, false, true );
//        for ( Node* bck : bckSet )
//        {
//            anyOrigin = anyOrigin || bck->drxn_ == 2;
//        }
//        if ( !anyOrigin )
//        {
//            int x = 0;
//            for ( Node* bck : bckSet )
//            {
//                bck->drxn_ = !d;
//            }
//            assert( false );
//            return;
//        }
//    }
    
    NodeSet bckSet = node->getDrxnNodes( !drxn );
    for ( Node* bck : getDrxnNodes( !drxn ) )
    {
        assert( bckSet.find( bck ) == bckSet.end() );
    }
    
    if ( drxn ? ends_[1] <= coord + 100 : coord - 100 <= ends_[0] )
    {
        Node* fwdNode = ( drxn ? node : this );
        
        NodeSet fwdSet = fwdNode->getDrxnNodes( 1, false, true );
        NodeSet revSet;

        for ( Node* fwd : fwdSet )
        {
            fwd->drxn_ = 1;
        }

        for ( Node* connected : fwdNode->getConnectedNodes( false ) )
        {
            if ( connected->drxn_ == 2 )
            {
                revSet.insert( connected );
                connected->getDrxnNodes( revSet, 0 );
            }
        }

        for ( Node* fwd : fwdNode->getDrxnNodes( 1, false, true ) )
        {
            fwdSet.insert( fwd );
            fwd->getDrxnNodesNotInSet( fwdSet, revSet, 0 );
        }

        for ( Node* fwd : fwdSet )
        {
            fwd->drxn_ = 1;
        }
        
        return true;
    }
    
    return false;
}

void Node::seedJoinLoci( Node** nodes )
{
    NodeSet fwdSets[2];
    NodeSet revSets[2];
    for ( bool drxn : { 0, 1 } )
    {
        fwdSets[drxn] = nodes[drxn]->getDrxnNodes( drxn, false, true );
    }
    
    for ( bool drxn : { 0, 1 } )
    {
        for ( Node* node : fwdSets[drxn] )
        {
            for ( Node* prv : node->getNextNodes( !drxn ) )
            {
                if ( fwdSets[drxn].find( prv ) == fwdSets[drxn].end()
                        && revSets[drxn].find( prv ) == revSets[drxn].end() )
                {
                    revSets[drxn].insert( prv );
                    prv->getDrxnNodesNotInSet( revSets[drxn], fwdSets[!drxn], !drxn );
                }
            }
        }
    }
    
    assert( false );
}

bool Node::seedLeap( Querier &bwt, NodeList &nodes, int minCoord, int maxCoord )
{
    struct BadPair
    {
        BadPair():redundant( false ){ edges[0] = edges[1] = NULL; };
        ReadId id;
        string seq;
        BadPair* edges[2];
        int ols[2], coord;
        bool redundant;
    };
    vector<BadPair> bps;
    
    for ( Node* n1 : nodes )
    {
        for ( bool drxn : { 0, 1 } )
        {
            for ( ReadMark &mark : n1->marks_[drxn] )
            {
                if ( mark.estimate < minCoord || maxCoord< mark.estimate ) continue;
                bool doGet = true;
                for ( Node* n2 : nodes )
                {
                    if ( n2->reads_.find( mark.id ) != n2->reads_.end() )
                    {
                        doGet = false;
                        break;
                    }
                }
                if ( !doGet ) continue;
                
                BadPair bp;
                bp.seq = bwt.getSequence( mark.id );
                bp.coord = drxn ? mark.estimate : mark.estimate - params.readLen;
                bps.push_back( bp );
            }
        }
    }
    
    for ( BadPair &bp1 : bps )
    {
        bp1.ols[1] = params.readLen / 2;
        if ( bp1.redundant ) continue;
        for ( BadPair &bp2 : bps )
        {
            if ( &bp1 == &bp2 ) continue;
            if ( bp1.seq.find( bp2.seq ) != bp1.seq.npos ) bp2.redundant = true;
            if ( bp2.redundant ) continue;
            if ( bp2.seq.find( bp1.seq ) != bp2.seq.npos ) bp1.redundant = true;
            if ( bp1.redundant ) break;
            int ol = mapSeqOverlap( bp1.seq, bp2.seq, bp1.ols[1] + 1 );
            if ( ol )
            {
                bp1.edges[1] = &bp2;
                bp1.ols[1] = ol;
                if ( !bp2.edges[0] || ol > bp2.ols[0] )
                {
                    bp2.edges[0] = &bp1;
                    bp2.ols[0] = ol;
                }
            }
        }
    }
    
    vector<BadPair*> ends[2];
    for ( BadPair &bp : bps )
    {
        for ( bool d : { 0, 1 } )
        {
            if ( !bp.edges[d] && bp.edges[!d] )
            {
                if ( bp.edges[!d]->edges[d] != &bp || !bp.edges[!d]->edges[!d] )
                {
                    bp.edges[!d] = NULL;
                }
                else
                {
                    ends[d].push_back( &bp );
                }
            }
        }
    }
    
    unordered_set<BadPair*> used;
    for ( bool d : { 0, 1 } )
    {
        for ( BadPair* bp : ends[d] )
        {
            vector<BadPair*> path = { bp };
            while ( path.back()->edges[!d] ) path.push_back( path.back()->edges[!d] );
            if ( d ) reverse( path.begin(), path.end() );
            string seq = path[0]->seq;
            for ( int i = 1; i < path.size(); i++ )
            {
                int ol = path[i-!d]->ols[!d];
                seq += path[i]->seq.substr( ol );
            }
            if ( used.find( path[0] ) != used.end() && used.find( path.back() ) != used.end() ) continue;
            used.insert( path.begin(), path.end() );
            MapNode* mn = new MapNode();
            mn->seq = seq.substr( 1, seq.length() - 2 );
            bwt.mapSequence( mn->seq, mn->ids, mn->coords );
            
            int i = 0;
            while ( i < mn->ids.size() )
            {
                bool found = false;
                for ( Node* node : nodes )
                {
                    if ( node->reads_.find( mn->ids[i] ) != node->reads_.end() ) found = true;
                }
                if ( found ) i++;
                else break;
            }
            mn->ids.erase( mn->ids.begin(), mn->ids.begin() + i );
            mn->coords[0].erase( mn->coords[0].begin(), mn->coords[0].begin() + i );
            mn->coords[1].erase( mn->coords[1].begin(), mn->coords[1].begin() + i );
            i = 0;
            while ( i < mn->ids.size() )
            {
                bool found = false;
                for ( Node* node : nodes )
                {
                    if ( node->reads_.find( mn->ids[i] ) != node->reads_.end() ) found = true;
                }
                if ( found ) break;
                else i++;
            }
            mn->ids.erase( mn->ids.begin() + i, mn->ids.end() );
            mn->coords[0].erase( mn->coords[0].begin() + i, mn->coords[0].end() );
            mn->coords[1].erase( mn->coords[1].begin() + i, mn->coords[1].end() );
            
            if ( !mn->ids.empty() )
            {
                mn->recoil();
                Node* node = new Node( mn, 0, mn->ids.size()-1, 1 );
                node->offset( path[0]->coord );
                nodes.push_back( node );
            }
            delete mn;
        }
    }
}

void Node::seedLoop( bool drxn )
{
    NodeSet fwdSet = getDrxnNodes( drxn );
    if ( fwdSet.find( this ) == fwdSet.end() ) return;
    NodeSet usedSet = { this };
    NodeSet loopSet = getDrxnNodesInSet( fwdSet, !drxn );
    for ( int i = 0; i < edges_[drxn].size(); )
    {
        if ( loopSet.find( edges_[drxn][i].node ) != loopSet.end()
                && edges_[drxn][i].node->seedLoop( loopSet, usedSet, edges_[drxn][i].node->seq_.length() - edges_[drxn][i].ol, params.maxPeMax, drxn ) )
        {
            edges_[drxn][i].node->offsetNode( !drxn );
            edges_[drxn][i].node->removeEdge( this, 0 );
            edges_[drxn].erase( edges_[drxn].begin() + i );
        }
        else i++;
    }
    if ( isContinue( drxn ) ) stop_[drxn] = 1;
    int x = 0;
}

bool Node::seedLoop( NodeSet &loopSet, NodeSet &usedSet, int len, int limit, bool drxn )
{
    usedSet.insert( this );
    if ( len > limit ) return true;
    for ( Edge &e : edges_[drxn] )
    {
        if ( usedSet.find( e.node ) != usedSet.end() ) continue;
        if ( loopSet.find( e.node ) == loopSet.end() ) continue;
        if ( e.node->seedLoop( loopSet, usedSet, len + e.node->seq_.length() - e.ol, limit, drxn ) ) return true;
    }
    return false;
}
    

void Node::seedSetDrxnNodes( Node* fork, NodeList &nodes, bool drxn )
{
    for ( Node* fwd : fork->getDrxnNodes( drxn ) )
    {
        fwd->drxn_ = drxn;
        fwd->validLimits_[0] = fwd->validLimits_[1];
        fwd->validLimits_[3] = fwd->validLimits_[2];
        if ( find ( nodes.begin(), nodes.end(), fwd ) == nodes.end() )
        {
            nodes.push_back( fwd );
        }
    }
    vector<Edge> edges;
    for ( Edge &e : fork->edges_[drxn] )
    {
        edges.push_back( e );
        e.node->removeEdge( fork, !drxn );
    }
    fork->edges_[drxn].clear();
    
    for ( Edge &e : edges )
    {
        addEdge( e.node, e.ol, drxn );
    }
}

Node* Node::seedSetOrigin( NodeList &forkList )
{
    Node* node = new Node();
    node->drxn_ = 2;
    node->ends_[0] = forkList[0]->ends_[0];
    node->ends_[1] = forkList[0]->ends_[1];
    node->seq_ = forkList[0]->seq_;
    node->validLimits_[0] = forkList[0]->validLimits_[1];
    node->validLimits_[1] = forkList[0]->validLimits_[1];
    node->validLimits_[2] = forkList[0]->validLimits_[2];
    node->validLimits_[3] = forkList[0]->validLimits_[2];
    
    int readCount[forkList.size()];
    readCount[0] = forkList[0]->reads_.size();
    
    for ( auto &read : forkList[0]->reads_ )
    {
        node->reads_.insert( read );
    }
    
    int32_t offset = 0;
    for ( int i( 1 ); i < forkList.size(); i++ )
    {
        int32_t overlap = forkList[i-1]->getOverlap( forkList[i], 1 );
        offset += forkList[i]->ends_[0] - forkList[i-1]->ends_[1] + overlap;
        node->seq_ += forkList[i]->seq_.substr( overlap );
        for ( auto read : forkList[i]->reads_ )
        {
            read.second.offset( -offset );
            node->reads_.insert( read );
        }
        node->ends_[1] = forkList[i]->ends_[1] - offset;
        node->validLimits_[0] = min( node->validLimits_[0], forkList[i]->validLimits_[1] - offset );
        node->validLimits_[1] = min( node->validLimits_[1], forkList[i]->validLimits_[1] - offset );
        node->validLimits_[2] = max( node->validLimits_[2], forkList[i]->validLimits_[2] - offset );
        node->validLimits_[3] = max( node->validLimits_[3], forkList[i]->validLimits_[2] - offset );
        readCount[i] = forkList[i]->reads_.size();
    }
    
    int seqLen = node->seq_.length();
    assert( node->ends_[1] - node->ends_[0] == node->seq_.length() );
    node->setCoverage();
    int x = 0;
    
    return node;
}

void Node::seedSplit( NodeList &nodes, int32_t coord )
{
    Node* node = new Node();
    node->ends_[1] = node->ends_[0] = ends_[1];
    ends_[1] = ends_[0];
    for ( auto it = reads_.begin(); it != reads_.end(); )
    {
        if ( it->second[1] <= coord )
        {
            ends_[1] = max( ends_[1], it->second[1] );
            it++;
        }
        else
        {
            node->ends_[0] = min( node->ends_[0], it->second[0] );
            node->reads_.insert( *it );
            it = reads_.erase( it );
        }
    }
    
    node->validLimits_[2] = node->validLimits_[3] = max( validLimits_[3], node->ends_[0] );
    node->validLimits_[0] = node->validLimits_[1] = max( validLimits_[0], node->ends_[0] );
    validLimits_[2] = validLimits_[3] = min( validLimits_[3], ends_[1] );
    
    node->seq_ = seq_.substr( seq_.length() - ( node->ends_[1] - node->ends_[0] ) );
    seq_.erase( seq_.begin() + ( ends_[1] - ends_[0] ), seq_.end() );
    for ( Edge &e : edges_[1] )
    {
        node->addEdge( e.node, e.ol, 1, false );
        e.node->removeEdge( this, 0 );
    }
    edges_[1].clear();
    node->addEdge( this, 0 );
    nodes.push_back( node );
}

void Node::seedValidate( NodeSet &seedSet, NodeSet &delSet, int32_t* validLimits, int32_t* ends, bool doDel )
{
    NodeList notValid[2] = { { seedSet.begin(), seedSet.end() }, { seedSet.begin(), seedSet.end() } };
    
    for ( bool drxn : { 0, 1 } )
    {
        NodeSet currSet = { notValid[drxn].begin(), notValid[drxn].end() };
        notValid[drxn].clear();
        while ( !currSet.empty() )
        {
            NodeSet nxtSet, currFwd;
            for ( Node* curr : currSet )
            {
                curr->getDrxnNodes( currFwd, drxn );
            }

            for ( Node* curr : currSet )
            {
                if ( curr->isDeadEnd( drxn ) && doDel )
                {
                    curr->drxn_ = drxn;
                    curr->dismantleNode( delSet, drxn );
                    seedSet.erase( curr );
                }
                else if ( currFwd.find( curr ) != currFwd.end() )
                {
                    nxtSet.insert( curr );
                }
                else if ( curr->validate( drxn ) )
                {
                    curr->getNextNodes( nxtSet, drxn );
                }
                else
                {
                    notValid[drxn].push_back( curr );
                }

                validLimits[drxn] = ( drxn ? max( validLimits[1], curr->validLimits_[2] )
                                      : min( validLimits[0], curr->validLimits_[1] ) );
            }

            currSet = nxtSet;
        }
    }
    
    if ( ends[1] - ends[0] > params.maxPeMean && doDel )
    {
        int cutoff = (params.maxPeMean * params.cover * 2 ) / params.readLen;
        for ( bool drxn : { 0, 1 } )
        {
            for ( Node* node : notValid[drxn] )
            {
                int misses = node->getEndMarks( drxn ) * 5;
                int hits = 2;
                int32_t endCoord = node->ends_[drxn];
                for ( Node* fwd : node->getDrxnNodes( drxn ) )
                {
                    endCoord = drxn ? max( endCoord, fwd->ends_[1] )
                                    : min( endCoord, fwd->ends_[0] );
                    misses += fwd->reads_.size();
                    hits += fwd->getPairHitsTotal();
                }
                
                if ( misses / hits > cutoff && hits < 4 )
                {
                    node->dismantleNode( delSet, drxn );
                }
            }
        }
    }
}

bool Node::seedValidate( bool drxn )
{
    if ( validated_ )
    {
        return true;
    }
    
    NodeList tNodes = this->getTargetNodes( drxn, true );
    NodeOffsetMap fwdMap = getDrxnNodesOffset( drxn, 0, true );
    NodeOffsetMap revMap = getDrxnNodesOffset( !drxn, 0, true );
    
    while ( seedValidate( tNodes, fwdMap, revMap, drxn ) );
    for ( Node* fwd : getDrxnNodes( drxn ) )
    {
        fwd->seedValidate( tNodes, fwdMap, revMap, drxn );
    }
    
    validated_ = validated_ || ( !isContinue( 0 ) && !isContinue( 1 ) && validLimits_[1] == ends_[0] && validLimits_[2] == ends_[1] );
    
    return ( drxn ? validLimits_[2] == ends_[1] : validLimits_[1] == ends_[0] );
}

bool Node::seedValidate( NodeList &tNodes, NodeOffsetMap &fwdMap, NodeOffsetMap &revMap, bool drxn )
{
    bool didPair = false;
    unordered_set<SeqNum> usedIds;
    NodeSet tSet = getDrxnNodes( !drxn ), hitSet;

    for ( ReadMark &mark : marks_[drxn] )
    {
        if ( drxn ? validLimits_[1] < mark.mark
                  : mark.mark < validLimits_[2] )
        {
            for ( Node* t : tNodes )
            {
                auto it = t->reads_.find( mark.id );
                if ( it != t->reads_.end()
                        && ( drxn ? it->second[1] <= t->validLimits_[2] : validLimits_[1] <= it->second[0] ) )
                {
                    didPair = true;
                    hitSet.insert( t );
                    usedIds.insert( mark.id );
                    pushValidLimits( mark.mark, drxn );
                    t->pushValidLimits( it->second[!drxn], !drxn );
                    NodeSet midSet = t->getDrxnNodesInSet( tSet, drxn );
                    auto r = pairs_.insert( make_pair( t, 1 ) );
                    if ( !r.second ) r.first->second++;
                    if ( this != t )
                    {
                        r = t->pairs_.insert( make_pair( this, 1 ) );
                        if ( !r.second ) r.first->second++;
                        pushValidLimits( ends_[!drxn], !drxn );
                        t->pushValidLimits( t->ends_[drxn], drxn );
                        for ( Node* node : midSet )
                        {
                            node->pushValidLimits( node->ends_[0], 0 );
                            node->pushValidLimits( node->ends_[1], 1 );
                        }
                    }
                }
            }
        }
    }

    for ( Node* node : hitSet )
    {
        node->removeMarks( usedIds, false, true, !drxn );
    }
    removeMarks( usedIds, false, false, drxn );
    
    return didPair;
}

void Node::seedValidate( NodeList &nodes, NodeSet &delSet, bool drxn )
{
//    while ( !currSet.empty() )
//    {
//        NodeSet nxtSet;
////        for ( Node* curr : currSet )
////        {
////            usedSet.insert( curr );
////            unordered_set<SeqNum> usedIds;
////            for ( Node* fwd : curr->getDrxnNodes( drxn, false, true ) )
////            {
////                for ( ReadMark &mark : curr->marks_[!drxn] )
////                {
////                    if ( fwd->reads_.find( mark.id ) == fwd->reads_.end() ) continue;
////                    usedIds.insert( mark.id );
////                    auto r = curr->pairs_.insert( make_pair( fwd, 1 ) );
////                    if ( !r.second ) r.first->second++;
////                    if ( fwd == curr ) continue;
////                    r = fwd->pairs_.insert( make_pair( curr, 1 ) );
////                    if ( !r.second ) r.first->second++;
////                }
////            }
////            
////            curr->removeMarks( usedIds, false, false, !drxn );
////            for ( Node* fwd : curr->getDrxnNodes( drxn, false, true ) ) fwd->removeMarks( usedIds, false, true, drxn );
////        }
//        
//        for ( Node* curr : currSet )
//        {
//            usedSet.insert( curr );
//            int maxReads = 0;
//            for ( Node* nxt : curr->getNextNodes( drxn ) )
//            {
//                int readCount = 0;
//                for ( Node* fwd : nxt->getDrxnNodes( drxn, false, true ) ) readCount += fwd->reads_.size();
//                maxReads = max( maxReads, readCount );
//            }
//            for ( Node* nxt : curr->getNextNodes( drxn ) )
//            {
//                if ( !nxt->stop_[drxn] && nxt->reads_.size() <= 2 && maxReads > 2 )
//                {
//                    nxt->dismantleNode();
//                    delSet.insert( nxt );
//                }
////                    int score[2]{0};
////                    for ( Node* fwd : nxt->getDrxnNodes( drxn, false, true ) )
////                    {
////                        score[0] += fwd->marks_[drxn].size();
////                        score[1] += fwd->getPairHitsTotal();
////                    }
////                    if ( !score[1] && score[0] > 4 && false ) nxt->dismantleNode( delSet, drxn );
//                else if ( usedSet.find( nxt ) == usedSet.end() ) nxtSet.insert( nxt );
//            }
//        }
//        currSet = nxtSet;
//    }
    for ( Node* node : nodes )
    {
        for ( Node* nxt : node->getNextNodes( drxn ) )
        {
            int readCount = 0;
            for ( Node* fwd : nxt->getDrxnNodes( drxn, false, true ) )
            {
                for ( auto read : fwd->reads_ ) if ( read.second[1] - read.second[0] == params.readLen ) readCount++;
            }
            if ( readCount <= 2 )
            {
                nxt->dismantleNode();
                delSet.insert( nxt );
            }
        }
        int thisCount = 0;
        for ( auto read : node->reads_ ) if ( read.second[1] - read.second[0] == params.readLen ) thisCount++;
        if ( thisCount < 2 && node->edges_[!drxn].empty() )
        {
            node->dismantleNode();
            delSet.insert( node );
        }
        node->sortEdges( 0 );
        node->sortEdges( 1 );
    }
    
    struct EdgeScore
    {
        EdgeScore( Edge &e, NodeSet &tSet, bool d )
        : n( e.node ), olPref( false ), hitPref( false ), altPref( false )
        {
            NodeList tNodes;
            for ( Edge &re : n->edges_[!d] ) if ( re.ol > e.ol ) olPref = true;
            for ( Node* bck : n->getDrxnNodes( !d ) ) tNodes.push_back( bck );
            for ( Node* fwd : n->getDrxnNodes( d, false, true ) )
            {
                for ( ReadMark &mark : fwd->marks_[d] )
                {
                    for ( Node* t : tNodes )
                    {
                        if ( t->reads_.find( mark.id ) == t->reads_.end() ) continue;
                        if ( tSet.find( t ) != tSet.end() ) hitPref = true;
                        else altPref = true;
                    }
                }
            }
        };
        Node* n;
        bool olPref, hitPref, altPref;
    };
    for ( Node* node : nodes )
    {
        if ( node->edges_[drxn].size() < 2 ) continue;
//        if ( node->seq_.find( "CAAAGTTCTGTTTGTTTAAAGTAGTGCTTGCA" ) != node->seq_.npos )
//        {
//            int x = 0;
//        }
        NodeSet tSet = node->getDrxnNodes( !drxn, false, true );
        vector<EdgeScore> edges;
        bool anyPref = false;
        for ( Edge &e : node->edges_[drxn] )
        {
            EdgeScore edge( e, tSet, drxn );
            edges.push_back( edge );
            if ( edge.hitPref || ( !edge.altPref && !edge.olPref ) ) anyPref = true;
        }
        if ( !anyPref ) continue;
        for ( EdgeScore &e : edges )
        {
            if ( e.hitPref || ( !e.altPref && !e.olPref ) ) continue;
            node->removeEdge( e.n, drxn );
            e.n->removeEdge( node, !drxn );
        }
    }
    
    for ( Node* node : nodes )
    {
        if ( delSet.find( node ) != delSet.end() ) continue;
        if ( node->seedDiminutive() )
        {
            node->dismantleNode();
            delSet.insert( node );
        }
    }
}

void Node::seedValidate( NodeSet &delSet, bool drxn )
{
    int minReads = 10;
    NodeIntMap scores;
    NodeList tNodes;
    for ( Node* bck : getDrxnNodes( !drxn, false, true ) ) tNodes.push_back( bck );
    for ( Node* fwd : getDrxnNodes( drxn ) )
    {
        int score = 0;
        for ( ReadMark &mark : fwd->marks_[drxn] )
        {
            for ( Node* t : tNodes )
            {
                if ( t->reads_.find( mark.id ) != t->reads_.end() ) score++;
            }
        }
        if ( score ) scores[fwd] = score;
    }
    for ( Node* nxt : getNextNodes( drxn ) )
    {
        if ( nxt->edges_[!drxn].size() > 1 ) return;
    }
    for ( Node* nxt : getNextNodes( drxn ) )
    {
        int readCount = 0, score = 0;
        bool doesContinue = false;
        for ( Node* fwd : nxt->getDrxnNodes( drxn, false, true ) )
        {
            readCount += fwd->reads_.size();
            if ( fwd->isContinue( drxn ) ) doesContinue = true;
            auto it = scores.find( fwd );
            if ( it != scores.end() ) score += it->second;
        }
        if ( score || ( readCount < 5 && doesContinue ) ) continue;
        if ( scores.empty() )
        {
            for ( Node* fwd : nxt->getDrxnNodes( drxn, false, true ) ) fwd->stop_[drxn] = 1;
        }
        else
        {
            removeEdge( nxt, drxn );
            nxt->removeEdge( this, !drxn );
            if ( nxt->edges_[!drxn].empty() ) nxt->dismantleNode( delSet, drxn );
        }
    }
}

void Node::setIds( int &id, bool drxn )
{
    if ( id2_ < 0 ) id2_ = id++;
    int i = 0;
    for ( Edge &e : edges_[drxn] )
    {
        if ( e.node->id2_ >= 0 ) continue;
        NodeSet nxtSet = e.node->getNextNodes( drxn );
        int32_t off = ends_[drxn] - e.node->ends_[!drxn] + ( drxn ? -e.ol : e.ol );
        e.node->offset( off );
        e.node->id2_ = id++;
        for ( int j = i + 1; j < edges_[drxn].size(); j++ )
        {
            bool independent = false;
            for ( Node* nxt : edges_[drxn][j].node->getNextNodes( drxn ) )
            {
                if ( nxtSet.find( nxt ) == nxtSet.end() ) independent = true;
            }
            if ( independent ) continue;
            off = ends_[drxn] - edges_[drxn][j].node->ends_[!drxn] + ( drxn ? -edges_[drxn][j].ol : edges_[drxn][j].ol ); 
            edges_[drxn][j].node->offset( off );
            edges_[drxn][j].node->id2_ = id++;
        }
        e.node->setIds( id, drxn );
        i++;
    }
}

void Node::trimSeed( Querier &bwt, NodeRoll &nodes )
{
    NodeList tests[2];
    int goods[2]{0};
    for ( Node* node : nodes.nodes )
    {
        int readCount = node->countReads( true );
        for ( int i = 0; i < 2; i++ )
        {
            if ( !node->edges_[i].empty() ) continue;
            if ( readCount > 2 ) goods[i]++;
            else tests[i].push_back( node );
        }
        if ( node->edges_[0].empty() || node->edges_[1].empty() || readCount > 1 ) continue;
        
        // NYI: remove a weak and redundant node
        NodeSet selfSet = { node }, lSet, rSet;
        for ( Edge &e : node->edges_[0] ) e.node->getDrxnNodesNotInSet( lSet, selfSet, 1 );
        for ( Edge &e : node->edges_[1] ) if ( lSet.find( e.node ) != lSet.end() ) assert( false );
    }
    
    for ( int i = 0; i < 2; i++ )
    {
        for ( Node* node : tests[i] )
        {
            if ( !nodes.find( node ) || !node->edges_[i].empty() ) continue;
            bool noMatches = false;
            int minOl = max( 1 + params.readLen / 2, 10 + (int)node->seq_.size() - node->getBestOverlap( !i ) );
            bwt.mapExtensions( noMatches, node->seq_, i, minOl );
            if ( noMatches ) nodes.erase( node );
            else assert( false );
        }
    }
    
    Node::merge( nodes );
    for ( Node* node : nodes.nodes ) node->setOrigin();
}
