/*
 * Copyright (C) 2017 Glen T. Wilkins <glen.t.wilkins@gmail.com>
 * Written by Glen T. Wilkins
 * 
 * This file is part of the Locass software package <https://github.com/gtwilkins/Locass>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "node.h"
#include <algorithm>
#include "shared_functions.h"

void Node::printSeed( Querier &bwt, NodeSet nodes[2] )
{
    struct BadPair
    {
        BadPair(){ edges[0] = edges[1] = NULL; redundant = false; };
        ReadId id;
        string seq;
        BadPair* edges[2];
        int ols[2];
        bool redundant, drxn;
    };
    
    vector<BadPair> bps;
    NodeList allNodes( nodes[0].begin(), nodes[1].end() );
    allNodes.insert( allNodes.end(), nodes[1].begin(), nodes[1].end() );
    for ( bool drxn : { 0, 1 } )
    {
        int32_t limits[2];
        bool first = true;
        for ( Node* node : nodes[drxn] )
        {
            if ( first || ( drxn ? node->ends_[0] < limits[0] : limits[0] < node->ends_[1] ) ) limits[0] = node->ends_[!drxn];
            first = false;
        }
        limits[1] = limits[0] + 1500;
        limits[0] -= 1500;
        for ( Node* node : nodes[drxn] )
        {
            for ( ReadMark &mark : node->marks_[drxn] )
            {
                if ( mark.estimate < limits[0] || limits[1] < mark.estimate ) continue;
                bool found = false;
                for ( Node* t : allNodes ) if ( t->reads_.find( mark.id ) != t->reads_.end() ) found = true;
                if ( found ) continue;
                BadPair bp;
                bp.seq = bwt.getSequence( mark.id );
                bp.drxn = drxn;
                if ( bp.seq.length() < 200 ) continue;
                bps.push_back( bp );
            }
        }
    }
    
    for ( BadPair &bp1 : bps )
    {
        bp1.ols[1] = params.readLen / 2;
        if ( bp1.redundant ) continue;
        for ( BadPair &bp2 : bps )
        {
            if ( &bp1 == &bp2 ) continue;
            if ( bp1.seq.find( bp2.seq ) != bp1.seq.npos ) bp2.redundant = true;
            if ( bp2.redundant ) continue;
            if ( bp2.seq.find( bp1.seq ) != bp2.seq.npos ) bp1.redundant = true;
            if ( bp1.redundant ) break;
            int ol = mapSeqOverlap( bp1.seq, bp2.seq, bp1.ols[1] + 1 );
            if ( ol )
            {
                bp1.edges[1] = &bp2;
                bp1.ols[1] = ol;
                if ( !bp2.edges[0] || ol > bp2.ols[0] )
                {
                    bp2.edges[0] = &bp1;
                    bp2.ols[0] = ol;
                }
            }
        }
    }
    
    vector<BadPair*> ends[2];
    for ( BadPair &bp : bps )
    {
        for ( bool d : { 0, 1 } )
        {
            if ( !bp.edges[d] && bp.edges[!d] )
            {
                if ( bp.edges[!d]->edges[d] != &bp || !bp.edges[!d]->edges[!d] )
                {
                    bp.edges[!d] = NULL;
                }
                else
                {
                    ends[d].push_back( &bp );
                }
            }
        }
    }
    vector<string> seqs;
    vector<int> olTotals;
    unordered_set<BadPair*> used;
    for ( bool d : { 0, 1 } )
    {
        for ( BadPair* bp : ends[d] )
        {
            int drxns[2]{0};
            drxns[bp->drxn]++;
            vector<BadPair*> path = { bp };
            while ( path.back()->edges[!d] ) path.push_back( path.back()->edges[!d] );
            if ( d ) reverse( path.begin(), path.end() );
            string seq = path[0]->seq;
            int olTotal = 0;
            for ( int i = 1; i < path.size(); i++ )
            {
                drxns[path[i]->drxn]++;
                int ol = path[i-!d]->ols[!d];
                seq += path[i]->seq.substr( ol );
                olTotal += ol;
            }
            if ( used.find( path[0] ) != used.end() && used.find( path.back() ) != used.end() ) continue;
            used.insert( path.begin(), path.end() );
            if ( olTotal < params.readLen * 10 || seq.length() < params.readLen * 2 ) continue;
            seqs.push_back( seq );
            olTotals.push_back( olTotal );
            cout << ">" << drxns[0] << " " << drxns[1] << endl << seq << endl;
        }
    }
    
    MapNode* mn = new MapNode();
    mn->seq = "CCCCCCCCCCCCCCCCCCTACTGAGCGAAATTTATCGGCCGGCACGATTTTCGAATTTCACCACACTAAATTAAAAATTGATTTCAAATTTGGGTCTCCCCTAAGGAATCCTGGACCCGCGCCTGTAGTAAGCACAATTTTTATTTACTGAACCCCCCCCCCCTTAAGCAAAAACGAAAAGAAGGTAAGATTGTGGATACTATCTTGGTTTAAATATAATTTTTTGCCAGGGGTGGGGGCTCGTCTTCTTTTTTCATTTTTTTATAGGTAAAATTGTGGTTACCGTCTTCGTTTTTAATTTTTGTTGTTGTTGCCAGGAGTGGGGTCCCGTACGGTGCCACCCCCATGCCCCCACGCTGGATCCGCCACTGCTGTGAACGCCTATAGACATTGCATTATTTTGAAAAATGAAGCACAGAAGCACGCGGCATAATCTAACTTTTAAAATGATTTGAGACCAAAGAAGCACATTTTTTGTTTTCATAGGTTTTTATTCATTTCTCTCAAAGAAAAATTATACATTTATAACATTGGATACAAAATAACAAAATAATTTAACATAGGTCTTTATAAATTTACCAATGATCTTTTACATTTACATACAAAAGTTACACCTCTTCATTTTCCTTTGGAGACAAAAAAATTATATATATATATATATATAAAAAGAGAAAATGCTACAAAACACCTACTACCCCCCCCCACCCCACACAACATTTAAACACATAACAAGTACAACAGTATACAAAACACACACTAACATAGAACGAACAAACAAACAAAAGTAGAGGGGGAAAAAAAAGAAAAGAGAGAAGAGAGGAGGGTCAGGAAGTTGTATATTGAGAAAAAAAAACTGAAAACATTTATTCTAAACTTTCCAAAGCTTCCCATTTCCTTAAATGAATTGAAAGTGTGTCTCTTTCCATTGAAAGTTTTTTCTCTTCATTTCTATTTTCCAACAATCTATATTCTATTTCTTTTGCTTTTGGAGGGTTTCCCTTCTCTCTACTGTGGAAAATCATATATTTAATCAAAATTAAAATGTGGTTCAATAATTGCTCTGTTTTAAAAGTAGTGTCATCTATTCCTATATGAATTTCTTTCCAGGATAATTTCTTCAGAATTGGTAAATTAAGTCTATCTCCACATTTCCCCCAGACTTCCTTTATTGTATTACATTCAAAGAATACATGTTGATAAGTTTCTTCAAAATTTTTGCAAAATGAGCACAAACCATTTTAATGGAACCTGAATCTATGTAAATGATGATTTGTATATAAAATATTATGCAATAATTTGAACTGAAATTCTCGCAGTTTACTACTTAAGGTACACATCCTTGGTTGAACATATATCTTTTCTACTTCTTTTCTTGGAATATTGTAAAGTGTCATTAAATTGTCGCCTGCCGAGTTTGTTTCTACATTCTTTTTAATTTGACTCTTATATACCATTTTTGCAGTTAAATCTTCAAATGTAAACACTTTCTTTGAACAAAATAAATTTTAAACTAAAGCCAGTGTGAATTGACTTTCTTAAAGGTTGAACACTCTGTTTCCATTCATAAGGGGCTACTTTATAAATTTTGTTTACTTTATCTATTTCCACTCTGCTCAAACCTAACATTATAAAATGAGCTTCAGGTTTCAATTCTCCATTTTCTTCACAAATGTGATGAAGTCGATATATATTTTTTAAAAACAAAGTTTCCTCAAATAAGGTTTGACCTTCTAGTTGAATAAAATTATTATTATACAATATTTCATTCCCTTTGTATCTCTCTTCTGTTTTAACATATTCTTTCATATCTATCCATGCTTTCAGAAGATTCTGATAAAAGGAAGGTAACATAAGTTTCACTGTATCTCTCCAATAATTGCAATAATATATTAAATTACCTCCTATCGGTCTCATTAAATATTTAAAGTATTGTTTCCATTTGATATCATGAGTTCCTGTTACAAGCCTTTTTATCCACATTATTCTTTGTGCTTTTACAAACAACCTAAAATTCATCATTTTGAGCCCACCCTGCTGATAGTCTAACATCATTGTACTTCTTTTAATTTTATCTTTACCTCTCCACAAAAAATCAAAACATATTACTTCCATTTCTTTGTATACCCTCTGGAACTGGCATTAGTGATGTTACATATGTCAATTTAGAGTATCCATATACTTTCATCAATTGAATTTTACCCATTAAAGTTAGGTCACGCTGTTTCCACCACGTCAGTAGTTTTTTACTTTTGCTCAATATTTCCTTATAATTCATTTTTTTCTCGATATCTACATGAACTGAAAAATAAACACCTAATATTTTAACAGCATCTACAAGTTTCCCAACGGAAATGTATTATTAGACACCTGTGGGCCCAGGGGCAGAATATATGTCTTATCCTTGTTTAACTTTAATCCTGATATTTTATAAAAAACCTTCTAAAACGTGTTCTATTTCCTTAACTGAACTCATATCTTTGATGAAGAGTGTTATATCATCAGCATATAATACTTGCTTTATTTCTGTATTTCCAAAACAAATTCCTTTTACCAATTGATTATTTCTAATCATATGAGCTAAAATTTCAATGCATAAAATGAACAAGTATGGAGATAATGGGTCTTCTTGTCCAATTCCTCTTTCAACCTTAAAATAACCTGTTGATGCGTTTCCATTCATAACACAACTTTCAGTATTAGTATAAAGTATATTCACCCATTTACAAAACAATGGTCCAAACCCAAATAAATTTAAGACTTTGTATAGAAAACAATGAGAAACAGAGTCGAATGCCTTTTCAAAATCTAAGGCCATCAAAAAAGCATTTTCCCTATAAAAAGAAGTATGAAAAATCATGTCATCTATTATTCTTATGGCTTTTCCAATGTTTCTATTCTTAACATAGCCAAGTTGATCAGAAGATACAATATCAGGTAAAATTTCTTGCAATCTCTTTGAAAGTATCTTTGTTAAAATTTTATAATCCACATTTAAAAGAGAAATCGGTCTGTAATCCTTAATAAAGTCTGAATCTTTATCTTTTTTTATGTATCAAGGTGATAACTGCTTGTCTCTGAGAGGCTGATAGTTCTCCATGATTAAAGGCTTCATTAAAAGATGCAAGGATTAGATCTCCAATTACCGGCCAAAATTTAAGATAAAACTCTACACTTAAGCCATCATTTCCTGGTGATTTATTTAATTTCATATTTTTTAATATTTCTATACATTCCCTTTCTACTATCTTTTCTTCACCTAAACCCCTTAAGGTCTCGTTCAATTTTGGCATGTTACTAGGGGAAAATTCTAAACCTCCATCTAGTACAACTTCTATTTTTTTTATACAACTGACTGTAAAAGTGTTTTATTCCCTCGACAATTTCTTTTTCCTTAGTAACAATCTTTCCGTTTACGTTTAATTGCTGTATTACACTTTTCTTTCTATTTGCTTCCATAAGCTGTTTAAAAACTGCTGTATTCTTCTCTCCACATTCATACCAAGAGGCCCTTGATCGTATTTTTAAACCTTCATTAATATAGTCATAAAGTACTCTTAGTTGTTGTTTCTTAATTTTCAGTTGTTCAAGGATATTTTTATAACGTACATTATTGATTGATAGTAAATTTTCTTCCAAGTCTTCAATTTCTTTTTCTAGCTTTTCTATTTTTTCCTTCCTTTCCCTTGCCCTTTTCTTTGAAAATTTAGTTGTAAACCTGCGTATTTCCATTTTGATATAGTCCCATAATACTCTCTTGTCTTTTATCTCAGATAACATTTCGTTCTTTAAAGTCTGTATTTCTTCCTTCATCTTTAAAACATAGTCTCTATCATTTACGAAGCTATTATTGAACTTCCAATAACCTCTTTTACCCTGAAAATTTCCAGACGTTCTATCATGCAGAACCAAATTAACAGCTGAATGGTCAGGTGCTAAGGAGGGAATAATGTCACATTTAGATGTTATCTGTTCTAAATTCTCTGATATAATGAAATAATCCAAACGGCTTTGCATAAATGGATTCCCTTGTCTATAAGTATATTGTTTTTTATCTTTATTTTTATTTCTCCATACATCTCTTAATTTAAATTCATCCATGAATTCTTCTAATTTGCTACTGAATTTTGATTGCTTCTTTGGAACTTGTCCAAAATCATCTAAGTTCTTGTCTCTAATAACATTAAAATCACCTCCAAGAACTACTGGGTTCCCTTCTGAATTGTTTCTATACAACAACTCCCTTAAATCCATTAAACATTTCATTTGCTCCCCTTCGTTATTTCCAGTAGGAAAATAAACATTTCCTAGCAACATCTTCTGACCTTGTATATTACATCTAATCAATACATATCTTCCATTTATGTCTGCACAAGTGTCACTAATTTCAATGTCTAACTTACTATTTATTAATACCAGAACTCCTCTACTGTGGCTTGTACCATGACTAAAGATACATTTCCCGCCCCACTCCAATTGCCATTTCTTTTCGATATGTTTCTTGTAAGTATATTATATCTATAGACTTTGTCCTAAACCAATTAAACATTTTTTCTCGTTTGCTTCTATCTCTAATTCCCCTCACGTTTAGTGTGAGATAGTTACATGAAAACAAGTTCCCTTTATTATCCATCTTTTTTCTTTTGAAATAAACCCATATCTATATATGAGTTGGGACCCTCTATAAATTCCGACCTTGCAGATAAAGGAATCAACTTTTGGCAAATTAATATTTTTAATGAAACAACCTCACGACCCTCTCCCCTACCAGAAAGGAAATTAAGAAAGAAAAAGGATATGTATACATACATGAGACTACTACAAATATTCGAGAACATACATTTGAAAAACAAAAAAAGAAAAGGAAAGAAAAAGAAAAGAACACAAGGAAACATAAGATGACAACATGAAACAGACAAATAACAGAGTTCGCGTGGCGAATCATACATGATGACTAATCAGACTGCCTTGCAAACGTTGCATGGCAGTCCCCTCCCCCCCCTCTCCCCTCTCCCCTAATTCAGCTTTCCTACTTATTTGTCATACAGCCTGCAATTGAAAATTATGGACTGTCTGACCTTTGTTTCTACATTTCCCTGTTCAAAAAAAATAAATAATATCTTCCTGCAAATCTACTACATCATGGTCTTTTTCCATGTAAAGGTAAATCAAAATAGAGGATAAACCACCCTCTATGCTATCTCCATCTCAATTCAACACTGTTCTTTCCTGCCTAGTATACAACTTGCAATTGCTATCTCAATCTCAATTCAAAACTTTTCTATCCTGCCTTCATTGTATAACGCTTACAATTCAAGACTATGCCATATCTCCCCTTCTTTCTACATTCAACAGTTCACAAAACAAATACCTTACTATACCTTACAGATCGACTACATTGTAACTCATTATCATTTGGATTAAGGTAGTGTTCCGAAACTGCTGCAAGTAAAATTGCATCGAGAAACTACTTCTCTTTTAACATTTGCAACAACACAGCACAGCAACAAAAAAAAAAAAAAAAAATTACTCCATCAATAAATATTCCTTCTGAGTTGCTTCTACAGTGTAAATACATTTCCTCTGTGCTATCTCCATCTCAATTCAACACTATTCTCTCTTGCCTTCATTGTACATACAGCTTGCCCTTTCAAACTACAGTATGCCATATCTCACCTACTTGTACATTCCAGTTAATAAAACCAATGACTTCCTGCATATCAACTGCGATTACATCAATGGTCTTTTTCATATTGGAGTACAACAAAAGAAGGGTTAAAACCCCCATGTATAAGTTATCATATGTCCAGCCCAGCATCTTCCCCCATTATTATGCCTTTTATCTACTAACCAAAGTACATGTGCTTCCTTTCTGTCAGTCTTCTGTCATTAATACTTGGATTAAGACTGTACTCTGAAACTAACCTAAACAAATTTGCATGAAGAAATCCCTTCTCTTTCATGTTTGTAATAACATATAAAGAATTCATACTCTCTACCTTTCTTTTTCCGTGCAAGAAATATTTCCACTCTCAACTTTTCAGAAGGAAATAGTCTACATATAATATTTCTTCAAAATAGCTCCTCTATTACATTTCCTCTGTGCTTTCTCAATCTCAATTCAAAACTTTTCTATGAATATGGCCTGACCCATAATCGTTCGATCAGCCTAAACCTGGTACAAGGCGACTTTGACCAAACTTTCAAAAGACCCTATCGTGCCCAGTCACCCGTGGCAGAAATGTTATGAATGGGGTATCATTGGACAGAAGAGATGTTACTCGCCATCATGAAATAAATTTCAAAGTCATATTGTTTGTGATATTCTAATAAAGAGCTACCAAAGTTGGGTACATTTTTTTGTAAACTCACTGTATACATAGAGAGAGAGAGAGTGGGGGAGGAGAGAAGGGAAGAGGGGGGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGATCCTGCTACTACTACTGCCGCTAGGTTACTGCTATAAAAACTACTATTTCTTAAAAGGCAAGTACACTCCAAAAATACCTTATTTTCAATAGAAATCAGACAATATGTAATCAGACAATTATTTCCCTCACTTTCACTACTATATAATATTTCTTTTGTCTATCTTCTTCTTCTCTCTCTCCCTCTCTCTCTCTCTCTCACACACACATACACACACACACATACACACTCACACACACTCTCTCTCTCTCCCTCTCTCCATCTCACTCTCATCTCTGTGTTTGTCTCTTTGTCTCTCCCTCCCCCCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTATATATATATATATAATCAGACAATATATAATACCTATATCCCTCACTCTCACTTTCTCACTCCCTCTCGTTTTTTTTTTCTCTCTCTCTCTCTATCTATCTCTATCTCTACCTATCTCTCTCTCTCTCTCTCTCTCTCTTTTTTTTTCTCTCTCTCTCTCTCTCTATCTATCTCTATCTCTACCTATCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTATCTCAATCGATCAATATCGTGATCAATCCAGCTGCATAAGGAAAACAATTATTAGGGGCTATAATATTGAACGCTTCACAAGTATTAGTATGAGTTCAGTTATATATTTTTATTTGACAAGTCTTGACAAATTCAGTATCAATAAGAGTTTAACAATTCGTCAACATTTCATGCACCTTTCACTGGCTTTGAGTCTCTTGTATCTGAATTTTAGACACAATAATGTTTTAGTCTCTGGTAAGATATGCATTCTGTCCAAGGAAAGACATTAGTGACTATTAGTATATTTACACAAGCAATCTTTTTTTATACAAATTGTACACCTCGGCGACCACATTGACGTCTTCTTCATTGACTGCGATCTCAACCACTTCAGGTGGTGAAGATGTCGTTATGCTTTCCGTCGTTGGATGCTCCTTCTCCTCACTTTCATTCTCACCCCAACGTCCTCGGTTACCATAGGGATGACGGTGGCCATCACGCCTGGGAGATCCTTCTTCGGTTCCGTTGCGTCTGTCGAAGGGACGGTCTCCGAAAGGCTTTCTACCGAAGGGGTTGACCCAGAAGGGCCTCATCTCAAACATTGGTCTGTCCTGATCTCCATCTCCGGTCTTGTTGTGATGACGATGGGGGTGATCTCCCGTCTCATTATGACCCTGGTGACCTTCTGTGTGGTTGCGTCTGCCGAAGTGGTTGAACCGGAAGGGCCTCGTATCATTTGGTTTGTCCTGATCTTGATCTCCCGTCTCATTATGTCCTTGGTGACCCTCTGTCTGGTTATGATGACGGTGGTGGTGGCCATGGTGGCCATGGTGGCCATGGTGGTGAGGGTGAGGACGGCCATCCTCCTCGTTGCGTTCATTGCGCTGGCCGAACGGTTGTTCCTCTGGTCGGTCCTGAGGTGGACCTTGACGGTGACCATGATGACGACGTCCATGACCATCAAACTGACCGCGCCCTCCTAGACCATCACCAATTTGTTGGGCAGCATCAGTTTCTTCTTCTCCATCACCACGCCTTCCTCCTTGGCCGAAGAAAGGTCTTCCTCCAGCACCATCTGGTCTGGAGCCACCAAATCCAGGTCCGTCGAATCTCCTACCACCCATCGGACCGCCATTTTGTCTGCGTCCATCCATATGTGGGGCACCAAATCCAGGTCCATCGAACCTCCTTCCACCCATTGGTCCACCATCTTGCCTAGATCCACCCATCTGCATTCCACCAGGCCTTCCTCCAAAGCGACCTTGTCCTCTCTCTCTGCCATTCTCATTTCCTCGCCGTTCATTGAAATCTCTTCGTGCGTGAGCTGTAAGGGTTAATGAAATAATCGAATTAATTAAGTAATCACATTCTGCATTATTATATTTTGCTCTACATTGGTTTATAGCAGGTGACAAATAAGAATGGTAACTCGCCTTCTTATATTTTTCCCTTTATGTTTAATCCTAATCCGTAAATGCGGTTCGATATTCAAAACGCCTAATTCTGACTGAATTAAATTTGATTACCAGATTGAACGTAAACATAATACACATCCTTTGTCATTCAGAAAACGGATTGGTGTAGGCTTAATAAATACAATTAATTATATTGTGTAACGAACAATTTAAAAATGCATATTACAAACTATGAAATAATCATATTTACTTCTGTGAGCCCTTCATTGGCTTTATATTTAGCACTTATGAAGTAATACCGAGTAAAATTTGATTTCTTACCCGAGATAGCAAGAGCAGCCACAATGGCAACGATCAATGTTGCTTTCACCTCCATGTTTGTAAGGTCTCTCCGATGCTACAAGCTTTCTCTAGATTCGTTGCCTTCCAAGAGAGAACTAGCTCCAAACTTAACAACTACCTGCTGGGCCACTGAATTTATAGGTTTTCTACCCTAGATTGATATCTCACACTAGTACCAGACCGTGTCAGGAATTACCAGGCATACCCTGTTCTAGTTGATCTTTTCCCCCTTTTTTTCTTCATTTTCACACTGTGTTAATATCTTTAACCTTTTATCAACCACTGATTTGGAGAGTGCGTTGTACGTACTAGTACCAAAACCAATTACTTATCTTCGGATATCCGGTAGAGCCATGTATTGGGTGACACCGATGTCGCGGCGTAGTACAGTAGTGACCCCTTGAGTTTGTGAGGGAGCTAACGGTCATCGGTTTCTCTCTCTCTCTCTCTCTCTCTCCCTCCTTCTCCTTCTCTCCCCCGATCCTTCTTTCTGAAAAAATTGCATTGATTCGAAAGCCATTTAACAAAGTTGTCAAAGAATCTAGGCAATAACAACATCATCATTACAATCATTATCATTACCATTATCATCATCATCATTATCACCATCAATATTCTAGTCATCATTTTCTTCGTTATCTTACAGTCGTCATCATCATCATTACCATTATCATCATTATCATCATCATCATAATCATAATCATCATTCGGAAATTCAAAAGTAATTCAGGACATCCGTTGAAACAGCCCCTCGTTCGTATCAACTCATATCAGTTACGATTCTAATAATTACATAATTATATCCACATTCTGAAGTTAACCTAATGGTGTATAATGCATTGTGAATGAATTGCAATTGCGTCCCTTGAAAATTATTTCGTCTCCCACAATTACAAAATTTTTGTGTAAGAACAGCATTTCTGTTCTGTTTTCAGTACCGAATTTATTATTCTAAATATGTATTTATCGAAGGGTCATGATAAATAAACATCCGGGGTAGTGAGCCTTCGGAAAACTGAAAAATCAATAATTCTTTTGATAAGGACGGTATATGTAAATCTAGCAAGAGCCTCCCTTTACATTTTCCTAGGCTTATTGCCTAATCCAGCGTTTTTCAACCGATGTGCCCCAAGACATTTTTAGGGTACCACAAAAGAATTTGAAGAATATATAAGATTTTTTTTTTTAATTCTTGGAATAACGTCGATTTCTTGAAAACCTTAACAACCACTGAAGTATGTAATTTCATGAGGAAATAGCAATTTACTGGATAGAAAATTGTCTTTCTTCCTTGCTCGCTTCACTCCTTCGCAAGACTTAGAAACATGATGATTTCTATCAACGAAGTGCCTTAATATTTGAGCATTGAGGTGCCCGAATAGCCTTCTATTTGACAGTTAGGCGCCCACATAATTATGTGATATATCTTTTATATACAAATTTCAATTTTACCACGCTCGTTCCCTTCACTCGCTCGCAACATTTAGGGATAATTCTGGGCAATGAGATGCCCGAATCTCCTCATATTCGTGCTTCGAATTGACTGCACATATTGAGTTTTGTATCAATGTATTCGGCAGCGAGGTGCCTGCACGTTTATTTTTATATTTTATCTAGTGTGTTGACTATAAAGTCAATTTTTAACGTATTAAAAGTGTGATGGAGCGGGACGAGTGTCAGAGTGATATAAGATGAATCTTCTGAATATTAATTTGGGATTAGGGTGACGCGAAACCTTTTTGTTTCTTAAAAAGGTGCCTTGACTAAAAAAAAAAGGGTAAAAAAACGCTGGCCTTCACGTTGATCTAATCCAATGAACTATAATTTCTTACAAGAAGAAACAAAAGCTTGTGTTCTTGCTGGAAATGGCTTCCCCAGACTAGCAATTAGTCAAGTAAATGGGGAGGCACGGGGCATATCCTCCGCCCAATCGAAAGCCAAAACATTGTTTTATAACAAATAAAACAAAACACAAAAACCCAGAGGTAACCGTTTTTAGATAGAAAAGGAGTAGCAGAGCGGAAAGAGAACGAGAAAGCAGATTGGTTGAGAGCTCGTCACGTGACCAGAAACATTTCATCTATTAAAGTACTACTGTATATGAGTGTACTATTTGGGAGTTAGAAAAAAAATGTGGATTTTTTTTTTTTTTTAATATAATTTTTTCTTTTCTTTTTCAAATCTTAATTTAATGAAAACAAAATATTTCAAATCTTTTTAGATAAAAATTGATATTTTTGGGGTCTAAATTTTTGTTTTCTAAATGGTATTTAAAAAATAAATAAATAAATGTTTGATGCAGGATATAAAAAACAAATATGGACTGCTCTGTAATCGGATGATGGTGAGAAATACCATTCCCTCGGTGGTGTTCACACCGGCCCTTCTATCACCCCCTCGGCTTCGCCTCGGGGTGATAGAGGGGCCGGTGTGAACACAACCTTGGGAGTGATAGTTCCCACCATCATCCTCATGAGCAGTCAATATTTGTATACTATTTTCTCCCTCTGTCTGTCTCTCTCTGTCTCTGTCTCTGTCTTTCTCTCTCTCTCTCTCACTCCCATCTCTTTATCTCTTTGTTTCTCTCTGTGTATGTCTCTCTCTCTCTCCCCCTTTCTCTATCTCAGTGATCTATCTCTATCTATCTCTATTTCTGTCTGTCCCTTGCTTTCTCTACCTTTTCTATCTATTTCACCCCCTCTCTCTCTCTCCCTCTCTCTCTCTCTCTCTCTTCTCTCTTAATCCCATCTTTCTCTGTCTGTCTCCCTCTGCCTTTCTCTCTATCTATCTCTCTTTTACCTCTTCAACCAATCAATATCGTGATCAATCCAGCTGCATAATAAAAATATATAAGGGGCTTTAATATTGAACGCTTCACAAGTATTTGTACGATTTCAATTATATATTTTTATTTAACAAGTCTTCAAAAATTCAGTATAAATAAGAGTTTGATAATTCGTCAGCATTTTTATGCACCTTTCACTGGCTTTCAGTCTCTTGTATCTGAATTTTTAGACACAATCCATGCTGTTGTCTCTGGTAAGATATGCATTCTGTCCAAGGAAAGACATTGATGACTATTATCAATATATTTACACAAGCAATATTTTAAAAACAAATTCTACACCTCGGCGACCACATTGATGTCTTCTTCATTGATTGCGACCACTTCAGGTGGTGAAGATGTCGTTACGCTTTCCGTCGTTGGATGCTCCTTCTCCTCACTTTCATTCTCACCCCATCGTCCTCGGTTACCATAGGGCCGACGATGGCCATCACGCCTGGGAGATCCTTCTTCGGTTCCGTTGCGTCTGTCGAAGGGACGGCCTCCGAAAGGCTTTCTACGGAAGGGGTTGAACCGGAAGGGCCTCATCTCGAACATTGGTCTGTCCTGATCTCCATCTCTGGTCTTGTTGTGATGACGATGGGGGTGGTCTCCCGTCTCATTATGACCCTGGTGACCTTCTGTATGGTTGCGTCTGCCGAAGGGACGGTCTCCGAAAGGCTTTCTACCGAAGTGGTTGTACCGGAAGGGCCTTGTATCATGTAGTTTGTCCTGATCTTGATCTCCCGTCTCATTATGACCTTGGTGACCTTCTGTGTGGTTATGATGACGGTGGTGGTGGCCATGGTCGCGATGGTGGTGAGGGTGAGGACGGCCATCCTCCTCGCTGCTTTTGTTGCGCTGACCAAACGGTTGTTCCTCTGCTTGGTCCTGAGGATGACCTTGACGGTGACCATGATGACGACGTCCAGGACCATCAAACTGACCGGGCCCTCCTAGACCATCACCAATTTGTTGGGCAGCATCAGTTTCTTCTTCTCCATCACCACGCCTGCCTCCTTGGCCGAAGAAAGGTCTTCCTCCAGCACCAACTGGTCTGGAGCCACCAAATCCAGGTCCGTCGAATCTCCTTCCACCCATCGGACCGCCATTTTGTCTCCGTCCATCCATCTCCGGGGCACCAAATCCAGGTCCATCGAACCTCCTTCCACCCATTGGTCCACCATCTTGTCTCCGTCCATCCATTTGTGGGGCACCAGAGTCAGGTCCATCGAACCTTTTTCCACCCATTGGTCCACCATCTTGCCTAGATCCACCCATCTGCATTCCACCAGGCCTTCCTCCAAAGCGACCTTGCCCTCTCTCTCTGCCATTCTCATTTCCTCGTCGTTCATTGTAATCTCTTTGTGCGTGAGCTGTAGGGGATAATGAAAAATACAAATCGAATTAATTAAGTGATCACATTCTGCATTATTATCTTCAGCTCTACATTGGGTTATGGCAGGTGACAAATAAGAATGGTAACTCGCCTTCTTTGATGTTTTTTCCCTTTATGTTTAACCCTATCGGTTCGATATTCAAAACGCCTAATTCTGACTGAATTGAACTTGAATACCAGATTGAACATAAAGATAATTCTTATCTTTTGCCATTCGACCAACGGATTGGTGTAGGCTTAAGAAATAATATAAATTATTTTGTGTAACGAACAATTTAGAAATGCATATTATAAAATATGAAATAATCATATATACTTCTGTGAGCTATTCGTTGGCTCTATATTTAGCACTTATCAAGTAATACCGAGTAATAATTTGATTTCTTACCCGAGATAGCAAGAGCAGCCACAATGGCAACGATCAGTGTCACTTTCACCATGTTAGTAATAGGTCTCTCCGATGCTATAGCTTTCTCTTGATTCGTAACCTTCTATAAGAGAACGAGCTCCAAACTGAATAACTATCTGCTGGATCACTGAATATATAGTCTTTCTAACATAGATTAAAATCACTTTCGTACCAGACCGTGTCAGGAATTACCAGGCATACCCTGTTCTAGTTGATCCCCCCCCCCTTTTTTTCTTTATTTTTATACTTTGTTAAAAAAATTTGAACCTTATATCAACCACTGATGTGGAGAGTGCGTTGTACGTACTAGTACCAAAACCAATTACTTCATCTTCGGATATCCGGTAGAGCCATGTGTTGGGCGACACAGATGTCGGGGATGTCGGGGATTACATTAGTAGTCACCCTTGGAGTTTTTGAGGGAGCAACGGTCATCGATTTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTCTTTCTCTTTTTCTCCCCCTTTCCCCCTATCCTTCTATTTGAAAAATTGCATTGATTCGAAAGCCATTTTAAAAAGTTATCAAAGAATCTAGGCAATAACAACATCATCATTACAATCATTATCATTACCATTATCATCATCATCATTATCACCATCAATATTCTAGTCATCATTTTCTCCGTCATCTTACAGTTGTCATCTTCATCATCATACCAATCATAATCATCACCATCATCATCATCATCATCATCATCTTCATTACCATTATCATCACTATCATCACCATCATCATCATCATAATCATTCGGAAATTAAAAAGTAATCTAGGACATCCTTTGAAACAGCCCCTCGTTCGTATCAACTCATATTAGTTACAATTCCAATGATTACATAATTATATCCACATTCTGAAATTAACCTAATGGTATATAATGCATTATGAATGAATTGCAATTGCGTTCCTTGAAAATTATTTCGTCTCCCACCATTACAACTTTTCTGTTACATACCTTTACTCTTTGACAAGAAGTCTGTTTGACTATAATTTGCAACAACATTTCTGTGTAAGAACGGCATTTCTGTTCTGTTTTCCAGTACCGAATTTATTAGTCTAAATATGTATTTATCGAAGGGTCGTGAGAAATAAACATCCGGGGTAGTGAGCCTTCGAAAAACTGAAAATCAATAATTCTTTTGACATGGACGGTATATGTAAATCTAACAAGAGCCTACCTTTACATTTTCCTAGGCTAATTGCCTAATCCAGCGTTTTTCAACCGATGTGCCCCAAGACATTTTTAGGGTACCACAAAAGAATTTGAAGAATATATAAGATTTAAAAAAAAATTCTTGGAATAACGTCGATTTCTTGAAAACCTTAACGACCACTGAAGTACAGTATGTAATTTCATGAGGAAATAGCAATTTACTGGATAGAAAATTGTCTTTCTTCCTTACTCGCTTCACTCCTTCGCAAGACTTAGAAACATGATGATTTCTATCAACGAAGTGCCTTAATATTTGAGCATTGAGGTGCCCGAATAGCCTTCTATTTGACAGTTAGGCGCCCACATAATTATGTGTTATATCTTTTATATGAAAACTTCAATTTTACCACGCTCGTTCCCTTCACCCGCTCGCAACATTTAGGGATAATTCTGGGCAATGAGATGCCTGAATCTCCTCATATTCGTGCTTCGAATTGACTGCACATATTGAGTTTTGTATCAATGTATTCGGCAGCGAGGTGCCTGGACATTTAATTCTATATTTTATCTAGTGTGTTGACTATAAAGTCAATTTTTATCGTATTAAAAGTGTCATGGAGCGGGACGAGTGTCAGAGTGATATCAAATGAATCTTTTGTAAATTAATTTGGAATTAGGGTGACGCGAAACCTTTTTGTTTCTTAAAAAGGTGCCTTGACTAAAACAAAAAGGGTAAAAAAACGCTGGCCTTCACCTTGATCTAATCCAATGAACTATAATTTCTTACAAGAAGAAACAAAAGCTTGTGTTCTTGCTGGAAATGGCTTCCCCAGACTAGCAATTAGTCAAGTAAATGGGGAGGCACGGGCATATCCTCCGCCCAATCGAAAGCCAAAACATTGTTTTATAACAAACAAAACAAAACACAAAAACCCAGAGGTAACCGTTTTTAGATAGAAAAGGAGTCGCAGAGCGGAAAGAGAACAAGAAAGCAGATTGGTTGAGAGCTCGTCACGTGACCAGAAACATTTCATCTATTAAAGTACTACTGTATATGAGTGTACTATTTGGGAGTTAGAAAAAAAATGTGGAATTTTTTTTTTTTTTAATATAATTTTTTCTTTTCTTTTTCAAATCTTAATTTAATGAAAACAAAATATTTCAAATCTTTTTAGATAAAAATTGATATTTTTGGGGTCTAAATTTTTGTTTTCTAAATGGTATTTAAAAAAAATTAAATAAATGTTTGATGCAGGATATAAAAAACAAATATGGACTGCTCTGTAATCGGATGATGGTGAGAACTACCACTCCCTCGGTGGTGTTCACACCGGCCCTTCTATCACCCCCTTGGCTTCGCCTCGGGGTGATAGAGGGGCCGGTGTGAGCACCACCTTGGGAGTGATAGTTCCCACCATCATCCTCATGAGCAGTCAATATTTGTATACTATCTTCTCCCTCTGTCTGTCTCTCTCTGTCTCTGTCTCTGTCTTTCTCTCTCTCTCACTCCCATCTCTTTATCTCTTTGTTTCTCTCTGTGTATGTCTCTCTCTCTCTCCCCCTTTCTCTATCTCAGTGATCTATCTCTATCCATCTTTATTTCTGTCTGTCCCTTGCTTTCTCTACCTTTTCTATCTATTTCACCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCTCTCTCTCTTTTCTCTCTTACTCCCATCTTTCTCTGTCTGTCTCCCTCTGCCTTTCTCTCTATCTATCTCTCTTTTACCTCTTCAACCAATCACAGCTGCATAGTGAAAATATAAGGGGCTTTAATATTGAACGCTTCACAAGTATTTGTACGATTTCAATTATATATATTTATTTAACAAGTCTTCAAAAATTCAGTATAAATAAGAGTTTGATAATTCGTCAGCATTTTCATGCACCTTTCACTGGCTTTCAGTCTCTTGTATCTGAATTTTTAGACACAATCCATGCTGCTGTCTCTGGTAAGATATGCATTTCTGTCCAAGGAAAGACATTGATGACTATTATCAATATATTTACACAAGCAATATTTTAAAAACAAATTCTACACCTCGGCGACCACATTGATGTCTTCTTCATTGATTGCGACCACTTCAAGTGGTGAAGATGTCGTTACGCTTTCCGTCGTTGGATGCTCCTTCTCCTCACTTTCATTCTCACCCCATCGTCCTCGGTTACCATAGGGCCGACGATGGCCATCACGCCTGGGAGATCCTTCTTCGGTTCCGTTGCGTCTGTCGAAGGGACGGCCTCCGAAAGGCTTTCTACCGAAGGGGTTGAACCGGAAGGGCCTCATCTCGAACATTGGTCTGTCCTGATCTCCATCTCTGGTCTTGTTGTGATGACGATGGGGGTGGTCTCCCGTCTCATTATGACCCTGGTGACCTTCTGTATGGTTGCGTCTTCCGAAGGGACGGTCTCCGAAAGGCTTTCTACCGAAGTGGTTGTACCGGAAGGGCCTTGTATCATGTAGTTTGTCCTGATCTTGATCTCCCGTCTCATTATGACCTTGGTGACCTTCTGTGTGGTTATGATGACGGTGGTGGTGGCCATGGTGGCGATGGTGGTGAGGGTGAGGACGGCCATCCTCCTCGCTGCTTTCGTTGCGCTGACCAAACGGTTGTTCCTCTGCTTGGTCCTGAGGATGACCTTGACGGTGACCATGATGACGACGTCCAGGACCATCAAACTGACCGGGCCCTCCTAGACCATCACCAATTTGTTGGGCAGCATCAGTTTCTTCTTCTCCATCACCACGCCTGCCTCCTTGGCCGAAGAAAGGTCTTCCTCCAGCACCATCTGGTCTGGAGCCACCAAATCCAGGTCCGTCGAATCTCCTTCCACCCATCGGACCGCCATTTTGTCTCCGTCCATCCATCTCCGGGGCACCAAATCCAGGTCCATCGAACCTCCTTCCACCCATTGGTCCACCATCTTGTCTCCGTCCATCCATTTGTGGGGCACCAGAGTCAGGTCCATCGAACCTTCTTCCACCCATTGGTCCACCATCTTGCCTCGATCCACCCATCTGCATTCCACCCGGCCTTCCTCCAAAGCGACCTTGTCCTCTCTCTCTGCCATTCTTATTTCCTCGTAGTTCATTGTAATCTCTTTGTGCGTGAGCTGTAGGGGATAATGAAGAAAAAATCGAATTAATTAAGTGATCACATTCTGCATTATTATCTTTAGCTCTACATTGGGTTATGGCAGGTGACAAATAAGAATGGTAACTCGCCTTCTTTGATGTTTTTTCCCTTTGTGTTTAACCCTATCGGTTCGATATTCAAAACGCCTAATTCTGACTGAATTGAACTTGAAAACCAGATTGAATATAAAGATAATTCTTATCTTTTGCCACTCGCCCAACGGATTGGTGTAGGCTTAAGAAATAATATAAATTATATTTTGTAACGAACAATTTAGAAATGCATATTATAAAATATGAAATAATCATATATACTTCTGTGAGCTATTCGTTGGCTCTATATTTAGCACTTATCAAGTAATACCGAGTAATAATTTGATTTCTTACCTGAGATAGCAAGAGCAGCCACAATGGCAACGATCAGTGTCACTTTCACCATGTTAGTAATAGGTCTCTCCGATGCTATAGCTTTCTCTAGATTCGTTGCCTTCTAAGAGAGAACGAGCTCCAAACTGAATAACTATCTGCTGGATCACTGAATTTATAGGCTTTCTATCATAGATTGAAATCACTTTCGTACCAGACCGTGTCAGGAATTACCAGGGATACCCTGGTCCAGTTGATCTCCCCCCTTTTTATCTTTATTTTCATACTTTGTTAATATCTTTAACCTTTTATCAACCACTAATTTGGAGAGTGCGTTGTACGTACTAGTACCAAAACCAATCACTTCATCTTCGGATATCCGGTAGAGCCATGTATTGGGTGACACCGATGTCGCGGCGTAGTACAGTAGTCACCCTTTGAGTTTGCGAGGGAGCTAACGGTCATCGGTTTCTCTCCCTCTTTCTCTGTCTGTCTGCCTGCCTGTCTGTCCGTCTGAGTATCTCTCTCTCTATCTCTCTCTATCTCTCCTTCTCCCTCTCTCCCCCGATCCTTCTATCTGAAAAATTGCATTGATTCGAAAGCCATTTAACAAAGTTATCAAAGAATCTAGGCAATAACAACATCATCAAAACAATCATCATCAATTTTCTAATCATCATTTTCATTATCATCACTAGTGTTATTATCTTTTTATCCTTCATCGTGCAGGCATCATCATCATCATCAACGCAATCGATTAATTATATTCAAGTGATTTTTTTTCCAAATGATTATTCCTTTTTTATGATTTCATAACTCGAAGCAAGAGGAATTTCATAACACAACATTGAAGCTCATATTTCTACTAAATAGGCCTACTGTTATATGGTGATACTGCGAACAAATGGAAAGTTGAAAACGATTTCATATGACGTAGTAAAACTAGATCTAGAAAAAGGTCACTTCATTCTTTCTATTTCGGAAATTAAAAAGTCCTTCAGGACATCCGTTGAATCAGCTCATATAGTTCGTATCAGGTCATACCCCGGTTACAATTACAATAATTGCATGTTTATATCCACATTCTGAAGTTAACCTAATGGTATAGGCAGGGGTGGCGATCCCAGGGGGACGGGGGGACACGTCCCTCTTTAATATTTTTAGGGGGATCGTCCCCCCCCCCCCCAGAAAATTTGAAAAAGTGCACACCAAAACAAAATGTATATGGGAAATACTGACTGCCAATACTGCAACACACTTCTAGGCTCTGGGGGCTCAAGTGTGCAGCGTTTAGACTAATCAAAATGCAAAAATCATCTCGCTCGGTCTCTATTCTCCCTCTTATAATATCCTTCAAAATGTACAAGTAAATATTGAAGAAAATCTGTAATCCGTTGTCACCATGTCAGTTTACACTGTTTGTTTACAAAGTGAAGAGTTATAGAAAAAGATCAGTGCTACAAAAATGAATATTAATCCGCTTGCTCTTTTCGGTAAGGAGTCACTACAACATTTATATATTTGCCAGAATTATATTTGACATTTCGATATCAATATACACGTAAAGGGCAGAGGCCTAGAGTGGAAATAGAGATCCAATTCGTGCACAAACTCTATCCTACTTACTAAAGTTTCCCTACTATACTGATATTCACAACCCTTCCAGTTTCATAAATGAGGTATCAAAATATGCTCATCTGACCTTAAATACCTATAAAACCCCTGAGCTTGCGGGGGTTACGCCCCCTGGATGCTCATCTGACCGTAATTAAATGCCTAAAACCCCTGAACTTCCGGGGGCTCTGCCCCTGGACCCCACTTAGGGCCCTTAGGCGGGCCCCTGAATGCTCATTTGACTGTAATTTAAAGCCTAAACCCCTGAGATTAAGGGGGCTCGCTACGCTCTACCTGATCATTGATACTTTAGACCCCCCCCCTCCCCAACGTTCCGCGGGGCATGCATGGGACATTATAAGAGTGGTGGTGACGCGGATTTTTTTTCTTCTGCCCCCTCCCAAACGCTTTTGCTCATAACGCCACTGGTCTCGCGCATTACATCCGGGTAAGAGAGCCTTTAAAAAACGGAAAATCCATTGTATTTCGTACCTGGACGGTATATGTAAATCTAGCAAGAGACTAGCATTTGCCTTTCGCTTGGCTAATTGCCTAAATACATGTATTGGGCTAATTCAACGAACTAAAGCAAAAGCTTGACGTGTTCTTGCTGGAAATGGCTTCCCCAGACAAGCAATAAGCGACGTAGAAAAAGGGAGGCATTGGGACACGTCCCCCGCCCAACCGAAAGCAAAAAGCAACAACAAATAAACAAATAAATTTACAAAACACAAAGTAAAATTATTTCGATAGAAAAGGGGAGAGAGAGAGAGAGCTCTAAGATGACGAAAAAGGAAACTACCCGACGGTTGCCTTGTTAATTTGAATTTCATTTCCAGGACACTTAAGGTAGAAAAAGAGATAGTTAAGAAATAGTAGTTTTTATAGTAGTAATCTAGCGTCAGTAGAAGTGGTAGCAGGAGCAATACAGTGCGTCCCAGAAAAATACGAAACCGAGAGTTATTGATGTTTTATCATAACTTAGTCACATTTATAATTAATAAATGACACATATTTGGAAAGCTTAGATCCTCCTCTTTCATTTGATGCAACTCATTTAATGCACATTTCAGCTGCCCGCCGTAGCAACAAACGGAATTAACAAAAGACTAAAACTCCGTTTCGTTGACAATCAGCCGTAGACGAAAGACTTCATGCATGGTTGATTGTCAACGAAACGGAGTTAAATCTTTTGTCAGTTCTGCTTGTTGCTACGGCAGGCAGCCAATGAAAACGAATTCGTTTGATAAAATTATGAAAATGCAGGCACTACTTTAAACAAACAGAACTTTGTTATTCCTAGCTCACTTTTCCTGACTGATGTGTCATGTGAAAGGGCAGAAACTAAACTTTCTAGAAATGTGATTTTCTCTTTGAAATTCAGAAACCGTCCGCCAAATGACCTTTTTTTAAACTTTGTTAAATGGCTTTCGAATCCATGCAATTTTTCAGATAGAAGGATAGGGGGGTACAAAAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAAAGAGACCAGTTACCGGTGCTTCCTACTGTACTACACCACGACATCAGTGCCACCCAATACATGGCTCTACCGGATATCCGAAGATGATGTAATTGTTTTTACGTACTGGTACAACACTCTCCAAAACAGTGGTTGCTAAGTCTAAGTATAGGATAAAGGTTAAACATATCAACATTGATATTGAAGAAAGAAAAAAAAGAGAAAAAAACGAAAAATAAACGGAAAAAACTAGACCAGGGTAAACCTGATAATTCCTGACACGGTCTGGTACGAAAGTGATTTCAATCTTTGGTAGAAAGCCTATAAATTCAGTGATCCAGCAGATAGTTGATCAGTTTGGAGCTCGTTCTCTTATAGAAGGCTACGAATCTAGAGAAAGCTTGTAGCATCGGAGATACCTTACAAACATGGAGGTGAAAGTGACACTGATCGTTGCCATTGTGGCTGCTCTTGCTATCTCGGGTAAGAAATCAAATTATTACTCGGTATTCCTTCATAAGTGTTAAATATTAAGCCAACAAATGACTCACAGTAGTATATTATTATTTTGATTTATTATAAAAGGTGTTTCTAACTTGTTTGTAACACAATAAAAATAACATTTATTCTTCGGCCTGCAGCATTCTGTTTTTTTTTTATGAAAAAAATGTTTCATGGTTCTTTACAATCTGGTTTTCATATTCAATTCGTTTAGAATTAGGCGTTTTGAATATCCAACCGCATGCATGCATTCTGGTAGAGTTAAACATAACGGGACCAGACATCGAAGAAGACAAATCTCCTAGCATAAACCAATGTAGAGCTAAAGATAATAATGCAGAATGTGATTAATTTTATTAATAAATTCGACTATTTCATTATCCCAACAGCTCACGCACAAAGAGATTTCAATGAACGACGAGGAAAGGAGAATGACACAGAGAGAGGACAAGGTGGCTTTGGAGGAAGGCCTGGTGGAATGCAGATGGGTGGTCCTAGGCAAGATGGTGGACCAATGGGTGGAAGGAGGTTCGATGGACCTGAATCTGGTGCCCCACAAATGGAAGGACGCAGACAAAATGGCGGTCCGATGGGTGGTAGGAGATTCGACGGACCTCGATTTGGTGGCTCCAGACCAGATGGTGCTGGAGGGAGACCTTTCTTCGGCCAAGGAGGCAGGCGTGGTGATGGAGAAGAAGAAACTGATGCTGCCCAACAAATTGGTGATGGTCTAGGAGGGCGCGGTCAGTTTGATGGTCATGGACGTGGACATCATGGTCACCGTCAAGGTCCTCCTCAGGACCGACCAGAGGAACAACCGTTCGGTCAGCGCAACGAAAGCAGCGATGAGGATGGCCGTCCTCACCCTCGCCACCATGGCCGCCACCACCAGCATCATCATCGCAACCACACAGAAGGTCACCAAGGTCACAATGAGACAGGAGATCACCCCCACCGTCATCACAACAAGACCGGAGATGGAGATCAGGACAGACCAATGTTTGAGATGAGGCCCTTCCGGTTCAACCCCTTCGGTAGAAAGCCTTTCGGAGACCGTCCCTTCGACAGACGCAACGGAACCGAAGAAGGATCTCCCAGGCGTGATGGCCAACGTCGGCCCTATGGTAACCGAGGACGTTGGGGTGAGAATGAAAGTGAGGAGAAGGAGCATCCAACGACGGAAAGCGTAACGACATCTTCACCACCTTAAGTGGTCGAGATCGCAGTCAATGAAGAAGACATCAATGTGGTCGCCGAGGTATAGAATTTGTTTAAACAAAAATTGCTTGTGTTAATATACTAATATAGTCACCAATGTCTTTCATTGGACAGAATGCATATCTTTAGTACCAGAGCCTACAACAGAATTTTGTCTAAAAAATCCAGATACAAGAAACTGGAAGCCAGTGAAAGGTGAATGAAATTTTGATAAATTATCAAAATCTAATTTTGTACTGAATTTTCGAAGTCTTGTTAAATAAAATATACAACTGAAATCATACAAATACTTGTGAAGGGTTCTATATTAAAGCCCCTAATATTTTCTTTATGCAGCTGGATTGATCACGATATTGATTGATTGAAGAGAGAAAAGAGAGATAGATAGAGAGAAAGGCAGAGGGAGACAGACAGAGAAAGATGGGAATGAGAGAGAAAGAAAGAGAGAGCAAGAGAGAGAGAGAGGGGGGGGGGGTCAAACAAATAGAAAAGGTAGAGGGAGAGAGAAAGAGAGAAGAAGAAGATAGATAAATAGAGATTATAAATATAAAGAGAGAAAGAGACACAGAGAGAGGACGGGGGGGGGGAGGTGTATGAAAACAGAAAGAGATAGTAATACTAGCAGTAGTATATAGTTGTAGTACTATACTACTGAGCCTACCACCACTTCAATTTCCACTACTACTACTACTACTACTACTACTACTACTACTAGGCTTTTATACTACTACTACTATTACTACTACTACTACTCATAGGCGCCGGAAGTGGGGGGGGGGCAGTTGCCCCCCCCCAGTCAAAAATGTGGGGGGGGGGGCAAAACGCATTTTTGCCCCCCCCCCCCCAAAAAAAAAAAACGCCCCCCCCCCCTCCAAAAAAAACCCCTAAATACAGTAAAGGAGTAAACATGGTTTGTATTTTCAATCCAAAAGAACGTAACAATAATAAAAACCTGAATTAAATCACATATACAATTCCATTCAAAGAAAAAGGAAAGTTCACAGGAATTAAATTTCATAAACATTGCGCATGCCACCTATATGGTATTTATCAATCGAGGTCTCTATAATAGCGATACGCGCATATCGTGGACATATTGTGCGAGAATGGGAAAGCGTGTCCGTTTTTTTGTTATAGGGGCGAGAAGACATGAGCCCCTGAACGCTGGTGTACTGATGGGGGGGGGGGGGTGATGTATTTCTTATTCGAAACAAGTGATTTACAAATGTTGATGTTGTGACATGATTTTCCGGCATTTTTTGTTTTTGTTTTTTGTAAGTCATACCTTTTTATGCGTTTGTTGGAAAATAAGAAATTCCAAAATTACAGTCAGGCGAAATACGCTTATTTAGAAGCCTTTATGTCATGGTCTGCAAAGTGGCTGGGCTCGGGCACCCCACCCCTCTCCTTTTTGAAAAAAAGTATGTTAAAGAGAAAAAGAAAGAAAGACGGAGAAAAAATAAGTGACCTGCCAATGTCACAAATAAGGTATAAAACATGCTCATCTGACCGTAATTAAATGCTTAAAACCCCAGAGCTTACGGGGGCTCCGCCCCCGAACCCCACCAAGGGACCTAAGACGGGCCCCTGGATGCTCATCTGACCTTAATTAAATACCTAAAACCCCTGAGCTTCCGGGGGCTCTGCCCCCTGGACCACACCAAGGGCCCTAAGGCGGGCCCTGGATGCTCATTTGACCGTAATTAAATACCTAAAACCCCTGAGCTTCCGGGGCTCTGCCCCCTGGACCACACCAAGGGCCCTAAGATGGCCCCTGGATGCTCATCTGACTGTAGTTATATATTTAAACCTCTGAGCTTCTTGGGGCTCTCCCCCCTTGGATCAAGTTAATTGACTTACAGAGGGCCCCTGGATGCTTATCTGACCGTAATTAAATACCTAAAACCCCTGAGCTTCCGGGGGCTCAGCCCCTTGACCCCCTGCCGAGGCTCATGCCCTGGACCCCACGCCAATTTACGCTCTACCTGATCGATAATACTCCACTTTGAAAAACGTTCCGCGGGACCTGCATGTAACGTGTAAGACTGGTGGTGATGCAGATTTTTCGTCTACCCCCCCCCCCTTCCGAACTTTTTTCTCACTACGTCACTGCCCCTAGAATGTGAGCCCCCTGGAATGTTTCCCCCCCCCCCCCATCCCAAACTGCTTCCGGCGCGCCTGCTAATACTACTACTACTACTGCTACTACGCTTTTATACTACTACTACTACTATTATATTGCCGCTGCTACTGCTACTACTACTACTGCTATATATTACTACTTAAGTATCTCCGAGGTTGTGGTAAGGGTTAAGCAGTTCCTGTCTTGTTCTTCTTCAGCTCTGCTACTCCTTTTCTATCTAAATTCTGTTACCTCCTGTTTTTGTTTCCTTTTTTTTCTCTTCTTCTTCTTCAACTCTTTAATTTAAAAAATAATGTTTTGGCTTTCGATTGGCGGAGGAGGTGTCCCGTCGATTCCCATGCCTCCCCATTTACTCGACTAATTTCTTGTCTGGGGAGGCCATTTCCAGCAAGAACACAAAGTTTTGCTTCTTTTTGTAAGAAATTTTAGTTCATTGAATTAGATCAAGGTTTAGGCCAAAGTTTTTCAACTTTTTTTTTAAAGTCAAGGCACCCTTTAAAAAAAAAAAACAAGGTTTCGCATCACCCTAATCCCAAATTAATTTACAGAATATTCATTTAACATCACTCTGACACTCGTCCTGCTCCATCACTGTACACATGAGCTCATTTGTTTTTATATTTTGCGAGCGAGCGAGCAAAAAATAAAATAACTCTTTTTAATATGATAATAATTGACTTTATAGTCAACCCACTAAATAAAATATAGAATTAAGCGTGCAGGCACCTCGCTGCCGAATACATAATTACAAAAATCATTACGTGTGGCCAATTCGAAGCACGAATATGAGGGAATTCGGGCATCTCATTGCCCAGAATTATCCAGTTTTTAAATGTTGCGAGCGAGTGAAGAGAACGAGCGTGGTATCAAATAGGCTACTCGGGCACCTCAATGCTCAAATATGGAGGCACTTTGCTGCCAGAAATCATCATGTTTCTAAGTGTTGCGAAGGAGCAAAGTGACCAAGGAAGAAAGACAATTTTCTGTCCAGTAAAATGCTATTTTCATGAGATGACATACTTAAGTTTGATATCTTTATTTATACACGGTTAAAAAAGCCCCAAAAGTTACAAGTCTGATTTCCATTGGGGCCGTATGAAACAATGTAAATACATCGAATTAACATAAAAATGATAATGGTACATCAAAATATGAAATAATCAAGATAAATATCTAAAAAAATAACGATAGAATAGTACTGCCGAAAAAGTATATTTATATGAATAACAATAATCATGAGTGTCCAAACAAGAGTACTGTAAATATACTTCAAATTAAAATTGGTAATAAGAATTGTTACTAGTGCATAAACTGCCAGAAATGATATATATCTATAAAAAAATCAAATGTGGCTGGTCAAGATACTGCATTATTACAGTTAAGGATATGATTACAATTTTATTTTATTTAATTCATTAAAAGAACATTTGAAAGTGAATCAAACTAACAAGCACAACAGATAAAACTCTATTATTTAATCATTTTCGGATAAAATGAAATAAAGCTATATTACATCATATGGAAAGAAGACAAACATTTGTGGTTGTTAAGATTTTCAAGAAATCGACGTAATTCCAATATATTTATTTTGTAATTGTATATATTATTTAAATTCTTTCGTGGCACCTTAGAGATGTCTTGCAGTACATCGATTGAAAAACGCTGGTTTAGGCAATTAGCCAAGGGAAAGGCAAATGCTAGGCTCTTGCTAGATTTACATATACCGTCCATGTAAAAAGTATTATTGATTTTTCAGTTTTCCGAAGGCTCGCTACCCCAGAGGTTTATTCATCACGACCCTTTGATAAATAGATATTCAAAATAATAAATTTGATACTGGAAAACAAAAACTAAATGCTGTTCTGACACAGAAATGTTTTGTCCAATATAGTCAAACACTCAAACAGACTACCTGCCAAAGAGCAAAGGTATGTAACATATCAAATTGTAATTGTGGGAGACGAAATAATTTTCAAGGAACGCAATTACAATTCATTCATATTGCATTATATACCATTAGCTTAACTTTTGAATGTGGATATAAACAAGCAATTATTGTAATTGTAACTGGTATCACATGATACGAGCTATAGGGGCTGATTCAACGGATGTCCTGAATTACTTTTTTAATTTCCGAAATAGAAAGAATGAAGTTACCTTTGTTTAAATCTAGTTTTAAAACGTCATATCAAAACATTTGTAACTTTCCATTTGTTCGCAAAATTTCCATAACAGTTGGCCTATTACGTACAAAATATGAGCTGCAATGTTGTGTTACGAAATTCCTCTTGCTCCGAGTTATGAAATCAAATAAAAACGAAATAAATTTTGAAAAGAAATCCCTCGAATAATGACCATCTATATGAATCGATTGCATTGATGATGATGATGATGATGATCAGGGGCGGCCGAGTGATTTACAAAGTTGGGGGGGGGGGGGCACCAACAAAAAGGGGCACTTTCTAGAGAAAAAAAGGGCACCCCTACAATGGGAAATCTCAAAGCAAAAATATACACAATTTTTAGACATTGGTATATACCCCTACATTGTGATTACATTATCAGGGATGATTTCGATATTTGTTTCTCTGTATACATTATACAGTATATTGCTTAAGTATTGTACTTTGCAGTTGGGTGTGAGGTCGCAGTGCGAAAAATTACATCTTATAAAGAAGAAGAACAAATTCTGATGGGGTTATAAGCACATTTTCATAACAGAAGACTGAAATGACCTTTGATAAGTAACATATTTATATCATTTATAAATGCGAGAGAGCGTTTAATCAAAAGTGAAAAGGGGCATTTCTCGTACCTGAAACGGGGCACTTACTTGAGGTTAATAAAGGCACTTATGAGAATGGAAAAATTGACAATAATTGCAAAGGGAAACAGGAAAAACTGTCGAAGGAAAAGGGGCACGTGTCCAAAAAGGGGCACTTATCTGAGGTGGAAAGGGAGAGGGGCATGTTTATAATGGAATAGGGGCACTTTTCAAAGTAGAAGGGGCACTTCTTACGAGGTTCAAGGGGGACTTTTCGTATGTAAAAAGGGGCACTTTTGGGATACTTGAAAAAGTGGGGGGGGGGGCACTATGCCCACCCCCGCCCCCAGGAGGGCCGCCTCTGATGATGATGATGCCTGCATGATGAAGGAGAAAAAGATAATGAGATTAGTAGTGATGATGATAATGATGATGATAATGGTAATGGTAATGATTGTTTTAATAATGTTTTTAATGCCTAGATTCTTTGATAACTTTGTTAAATGGCTTTCGAATCCATGCAATTTTCAGATAAAAGGAGAGGAGAGAGAGAGAGAGAGACAGGCAGGCAGAGAAAGAGAGAGAGAAACCGATGACCGTTAGCTACCTCACAAATTCCTAGGGTGATTGCCAGGGGCGGCGATTTCTTTTCATGACCGGGGGGGACGAAATGCGAGGGACGGCGGCGTATAATGATCAAAAACGTTTTTTTTTTTTTTTTTTTTTTTTGGGGGGGGGGGGGGGGGAGAAAATCCGCAACCCCACTCTTACATGGTACATGCAGGCCCTGCGGAACGTTTTTCAAAGTATGGGGGGGGGGCTTCGATCAGGTAGAGCAAAGCGAGCGAAGCAAGTGGAGCTTAAATTGGCGTGGGCTCAGCTCAGGGTTTTTAGGCATTTATTAGGGAAAACCATGCCATTTCAGAAACATTTGTAAATCACTGGTATCGAGTTAGAAAAAAATCAAGTTTGAACTTTATTAAGGGGCAACTACCCCCAATCCCCCCCCCCCCCCATCATTACGCCAGGGCGAGGGAGCATAGTGAACGAGAGGGGTGAAGGTGACGGAAGTGACTACCCCCCCCCCCTCCCACCGCAGGTTTTTGAAGTTTTGTTGTATTAACAAAATATAAAAACAAGCAATATATCTTTTTCACACTTCACTTTTCAAGAATATTTACTGTACACTTTGAAGAATATTATGCGAGGGACATAGCTCCCGAGCGAGAAGATTATTGCATTTTTATTTGTCTAAACGCTGCACTCTTAGCAACGACTTAAACTTTAAAAAAGTCTTTGGGTAATAAACAGAACCATTAACAACCTTTTTAACTTAACACTTATAAATTTGCATATTGCGCATAATTTATCAAATTACCAAATTAATTACATATTACTTTCCAAAACAAAGTCACATCCTTACAATATAACATAAAGTGAAAAGTTGAGTCAACTTGTCCACAAGAGTTGCATAAATTATTCACAACTTGCCATTAATATAAGTTTTCTTTTGAGGCAACAAACCTGTGAATCATCTTGAAATTAAATTGTTTAACTTTATTATTACGAATTTGCTTTAATTAAATGAAAATACATCCTTCCAAACAAAGTCATTATCTCAATCTAAAAAGGAATTCCAAAAATAAATGAAATTTGGTTCTCTTGACTTAATAACAAACGATAGTAATCTTTCACTTTCATAACAAAAACATTCACTTTATCCCCTGTTTCTATTTCTAAAAGATTCGAAATATCACATTCATGTTCAAAATCATTATCATAGCTTAATCTATATAACCAATACATTAATTATGATGATGATAATGGGGATGATTATGATTGTTATAATGATTGCCCAGATTTTTTTGACAACTTTCTTAATGGCTTTCGAATCAATGTAATTTTGTTTAGAAAGCGGATGAGAGGGAGAGAGAGAGAGAGAGAGAAAGAGAGAGAGAGAGAGAGATAGAGAGAGAATATCGTTGACCGTTGCTTCCTTGAAAATTCCAAGGGTGACTACCCGATATCAGTGTCACCCAATACTTGGCTCTACCGGATATCCAAAGATGATGTAATTGGTTATACGTCCTGGTACAAAAAGGTTACAAATATTAACGAGGTTTGACATCGAAAAAACAGCAACAACAAAATAAAAACAATGATCAACTGGAACAGGGTATACCTGGTAATTCCTGACACGGTCTGGTACGAAAGTGATTTCAAGCTATGGTAGAAAGCCTATAAATTCAGTGATCCAACAGATAGTTGTTCAGTTTGGAGCTCGTTCTCTTATAGAATGCTACGAACCTATAGAAAGCTATAGCATCGGAGAGACCTATTACTATCATGGTGAAAGTGACACTGATCGTTGCCATTGTGGCTGCTCTTGCTATCTCGGGTAAGAAATCAAATTATTACTCGGTATTCCTTCATAAGTGGTATATTGAGCCAACAAAATTACTCACATAAGTATATTGTTATTTTGATTTATTATAATATGTGTTTCTAACTTGTTTGTGACACAATAAAAAATAACATTTATTCTGCGGCCTGCAGCATTCTGGTTTTTTTAATGAAAAAAATGTTTCATGGTACTTTACAATCTGGTTTTCAAATTCAATTCGGTTAAAATTAGGCGTTTTGAATATCCAACCGCATGCATGCATTCTGGTAGAGTTAAACATAACGGGACCAGACATCGAAGAAGACAAATCTCCTAGCATAAACCAATGTAGAGCTAAAGATAATAATGCAGAATGTGATTAATTTTATTAATAAATTCGACTATTTCATTATCCCAACAGCTCACGCACGAAGAGATTTCAATGAACGACGAGGAAAGGAGAATGGCACAGAGAGAGGACAAGGTGGCTTTGGAGGAAGGCCTGGTGGAATGCAGACGGGTAGTCCTAGGCAAGATGGTGGAAGGAGGTTCGATGGACCTGAATCTGGTGCCCCACAAATGGATGGACGCAGACAAAATGGCGGTCCGATGGGTGGTAGGAGATTCGACGGACCTCGATTTGGTGGCTCCAGACCAGATGGTGCTGGAGGGAGACCTTTCTTCGGCCAAGGAGGCAGGCGTGGTGATGGAGAAGAAGAAACTGATGCTGCCCAACAAATTGGTGATGGTCTAGGAGGGTCCGGTCAGTTTGATGGTCCTAGACGTGGTCATCATGGTCACCGTCAAGGTCCTCCTCAGGACCGACCAGAGGAACAACCGTTCGGTCAGCGCAACGAAAGCAGCGATGAGGATGGCCGTCCTCACCCTCGCCACCATGGCCGCCACCACCAGCATCATCATCGCAACCACACAGAAGGTCACCAAGGTCACAATGAGACAGGAGATCACCCCCACCGTCATCACAACAAGACCGGAGATGGAGATCAGGACAGACCAATGTTTGAGATGAGGCCCTTCCGGTTCAACCCCTTCGGTAGAAAGCCTTTCGGAGACCGTCCCTTCGGCAGACGCAACGGAACCGAGGAAGGATCTCCCAGGCGTGATGGCCAACGTCGGCCCTATGGTAACCGAGGACGTTGGGGTGAGAATGAAAGTGAGGAGAAGGAGCATCCAACGACGGAAAGCGTAACGACATCTTCACCACCTTAAGTGGTCGAGATCGCGATCAATGAAGTCGCCGAGGTGTAGAATTTGTTTTTAAAATATTGCCTGTGTAAATATACTAATAATAGTCACCAATGTCTTTCCTTGGACATAAGCATATATTACCAGAGACTACAATAATGTCATACAATTCAGATACAAGAGACTGAAAGCCAGTGAAAGGTGCATGAAAATGCTGACGAATTATTAAAATCTAATTTTATACTGAATTTTTGAAGACTCGTTAAATAAAAGTATATAACTGAACTCATACAAACACTTGTGAAGCGTTCAATATTATAGCCTCTAATAATGATTATTATTTTCCTTCTGCAGCTGTATTGACCATGATATTGATCTATTGAGATTAGAGAGAGAGAGAGAGAGAGAGAGAGAGATAATATATCAAATAATAGAGAAAGAGAAGGAAATGAGAAGCGAGGAGAAGAGGAAAAATATTGTTACCTATGGCCAGGGTTCGCAAAAGTGAAATACTTCACTGTTGCCCAGAGGCACGCGATGATATTGAGACATTGAGAGAGAAAGAGAGAGAGAGAGAGAGAGGGAGAGTGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAGAAAGAAAGGGAGGGGGAGTGAGAAAGTGAGAGTGAGGGAGTATTATATATACAGTGCGTCCCAGAAAAAACGAAACCGAGAATTATCGATGTTTTATCATAACTTAAGCACAACTATAATTGATAAATGACACATATCTGGAAAGCTTGGATCCTCCTCCTTCATCTGATGCAACTTATATAATGCATATTTGACGCATGAGTGATTAAAAGCAATTTGAAGAGAGGAAACCAAAAAGTCATTTGGCGGGCGATATCTGAATTTCAAAGAGAAAATGCTATTTCTAGAAAATTGAGTTTCTGCGCTTTCATATGACACCTCAATCAGGAAAATGAGCTTGGAATAACAAAGTTCTGTTTGGTTAAAGTAGTGCTTGCATTTCCATAATTGTATTAAAACGAATTCCGCGGATCCTTCTATAGTGTCACCTAAATGTCGACGGCCAGGCGGCCGCCAGGCCTACCCACTAGTCAATTCGGGAGGATCGAAACGGCAGATCGCAAAAAACAGTACATACAGAAGGAGACATGAACATGAACATCAAAAAAATTGTAAAACAAGCCACAGTTCTGACTTTTACGACTGCACTTCTGGCAGGAGGAGCGACTCAAGCCTTCGCGAAAGAAAATAACCAAAAAGCATACAAAGAAACGTACGGCGTCTCTCATATTACACGCCATGATATGCTGCAGATCCCTAAACAGCAGCAAAACGAAAAATACCAAGTGCCTCAATTCGATCAATCAACGATTAAAAATATTGAGTCTGCAAAAGGACTTGATGTGTGGGACAGCTGGCCGCTGCAAAACGCTGACGGAACAGTAGCTGAATACAACGGCTATCACGTTGTGTTTGCTCTTGCGGGAAGCCCGAAAGACGCTGATGACACATCAATCTACATGTTTTATCAAAAGGTCGGCGACAACTCAATCGACAGCTGGAAAAACGCGGGCCGTGTCTTTAAAGACAGCGATAAGTTCGACGCCAACGATCCGATCCTGAAAGATCAGACGCAAGAATGGTCCGGTTCTGCAACCTTTACATCTGACGGAAAAATCCGTTTATTCTACACTGACTATTCCGGTAAACATTACGGCAAACAAAGCCTGACAACAGCGCAGGTAAATGTGTCAAAATCTGATGACACACTCAAAATCAACGGAGTGGAAGATCACAAAACGATTTTTGACGGAGACGGAAAAACATATCAGAACGTTCAGCAGTTTATCGATGAAGGCAATTATACATCCGGCGACAACCATACGCTGAGAGACCCTCACTACGTTGAAGACAAAGGCCATAAATACCTTGTATTCGAAGCCAACACGGGAACAGAAAACGGATACCAAGGCGAAGAATCTTTATTTAACAAAGCGTACTACGGCGGCGGCACGAACTTCTTCCGTAAAGAAAGCCAGAAGCTTCAGCAGAGCGCTAAAAAACGCGATGCTGAGTTAGCGAACGGCGCCCTCGGTATCATAGAGTTAAATAATGATTACACATTGAAAAAAGTAATGAAGCCGCTGATCACTTCAAACACGGTAACTGATGAAATCGAGCGCGCGAATGTTTTCAAAATGAACGGCAAATGGTACTTGTTCACTGATTCACGCGGTTCAAAAATGACGATCGATGGTATTAACTCAAACGATATTTACATGCTTGGTTATGTATCAAACTCTTTAACCGGCCCTTACAAGCCGCTGAACAAAACAGGGCTTGTGCTGCAAATGGGTCTTGATCCAAACGATGTGACATTCACTTACTCTCACTTCGCAGTGCCGCAAGCCAAAGGCAACAATGTGGTTATCACAAGCTACATGACAAACAGAGGCTTCTTCGAGGATAAAAAGGCAACATTTGCGCCAAGCTTCTTAATGAACATCAAAGGCAATAAAACATCCGTTGTCAAAAACAGCATCCTGGAGCAAGGACAGCTGACAGTCAACTAATAACAGCAAAAAGAAAATGCCGATACTTCATTGGCATTTTCTTTTATTTCTCAACAAGATGGTGAATTGACTAGTGGGTAGATCCACAGGACGGGTGTGGTCGCCATGATCGCGTAGTCGATAGTGGCTCCAAGTAGCGAAGCGAGCAGGACTGGGCGGCGGCCAAAGCGGTCGGACAGTGCTCCGAGAACGGGTGCGCATAGAAATTGCATCAACGCATATAGCGCTAGCAGCACGCCATAGTGACTGGCGATGCTGTCGGAATGGACGATATCCCGCAAGAGGCCCGGCAGTACCGGCATAACCAAGCCTATGCCTACAGCATCCAGGGTGACGGTGCCGAGGATGACGATGAGCGCATTGTTAGATTTCATACACGGTGCCTGACTGCGTTAGCAATTTAACTGTGATAAACTACCGCATTAAAGCTTATCGATGATAAGCTGTCAAACATGAGAATTGATCCGGAACCCTTAATATAACTTCGTATAATGTATGCTATACGAAGTTATTAGGTCCCTCGACTATAGGGTCACCGTCGACAGCGACACACTTGCATCGGATGCAGCCCGGTTAACGTGCCGGCACGGCCTGGGTAACCAGGTATTTTGTCCACATAACCGTGCGCAAAATGTTGTGGATAAGCAGGACACAGCAGCAATCCACAGCAGGCATACAACCGCACACCGAGGTTACTCCGTTCTACAGGTTACGACGACATGTCAATACTTGCCCTTGACAGGCATTGATGGAATCGTAGTCTCACGCTGATAGTCTGATCGACAATACAAGTGGGACCGTGGTCCCAGACCGATAATCAGACCGACAACACGAGTG";
    bwt.mapSequence( mn->seq, mn->ids, mn->coords );
    mn->recoil();
    Node* node = new Node( mn, 0, mn->ids.size()-1, 4 );
    NodeList islands  = { node };
    int32_t dummy[2];
    ExtVars ev( allNodes, islands, dummy, bwt );
    IslandVars iv( ev, 1 );
    node->extendCount_ = 100;
    node->extendIsland( iv, 0 );
    NodeSet currSet = { node };
    bool drxn = 1;
    while ( iv.merged[0].empty() && !currSet.empty() )
    {
        for ( Node* isl : currSet )
        {
            if ( !isl->isContinue( !drxn ) ) continue;
            isl->extendCount_ = 99;
            isl->extendIsland( iv, !drxn );
        }
        currSet.clear();
        for ( Node* node : islands )
        {
            if ( node->isContinue( !drxn ) ) currSet.insert( node );
        }
    }
    
    int iBest = -1;
    int bestTotal = 0;
    for ( int i = 0; i < seqs.size(); i++ )
    {
        if ( olTotals[i] > bestTotal )
        {
            iBest = i;
            bestTotal = olTotals[i];
        }
    }
}

bool Node::fixSeed( IslandVars &iv, bool drxn )
{
    vector<GoodPair> gps, ggps;
    vector<BadPair> bps;
    fixSeedGetPairs( iv.ev.bwt, gps, bps, drxn );
    
    for ( int i = ends_[0] + 100; i < ends_[1]; i+=100 )
    {
        vector<int> dists[2];
        for ( GoodPair &gp : gps )
        {
            if ( gp.coords[0] < i && i < gp.coords[1] ) dists[!gp.isPe].push_back( gp.coords[1] - gp.coords[0] );
        }
        int medianDist[2]{0};
        for ( int j : { 0, 1 } )
        {
            sort( dists[j].begin(), dists[j].end() );
            if ( dists[j].empty() ) continue;
            medianDist[j] = dists[j][dists[j].size() / 2];
        }
        cout << "Coord " << i 
                << "| PE Count " << dists[0].size() << ", Median " << medianDist[0] 
                << "| MP Count " << dists[1].size() << ", Median " << medianDist[1] << endl;
    }
    
    for ( GoodPair &gp : gps )
    {
        int diff = gp.coords[1] - gp.coords[0];
        if ( diff < 0 ) continue;
        if ( gp.isPe && abs( diff - params.maxPeMean ) > 200 ) continue;
        if ( !gp.isPe && diff - params.maxMpMean > 1000 ) continue;
        ggps.push_back( gp );
    }
    
    vector<PairPath> paths = fixSeedGraphPairs( bps, drxn );
    
    if ( paths.empty() ) return false;
    
    NodeList nodes = { this };
    for ( Node* fwd : getDrxnNodes( !drxn ) ) nodes.push_back( fwd );
    
    if ( fixSeedGetNodes( iv, paths, drxn ) ) return true;
    
    return fixSeedSetEdge( iv, ggps, drxn );
}

bool Node::fixSeedGetNodes( IslandVars &iv, vector<PairPath> &paths, bool drxn )
{
    NodeList ends;
    for ( Node* node : iv.ev.island ) if ( node->edges_[drxn].empty() ) ends.push_back( node );
    for ( int i = 0; i < paths.size(); i++ )
    {
        if ( paths[i].olTotal < paths[0].olTotal / 3 ) break;
        for ( int x : { 0, 1 } )
        {
            int coords[2]{-1,-1};
            for ( int j = 0; j < paths[i].path.size(); j++ )
            {
                bool found = false;
                for ( Node* node : iv.ev.island )
                {
                    if ( found ) break;
                    if ( node->reads_.find( paths[i].path[j]->id ) != node->reads_.end() ) found = true;
                    if ( node->seq_.find( paths[i].path[j]->seq ) != node->seq_.npos ) found = true;
                }
                if ( !found && coords[0] == -1 ) coords[0] = j;
                if ( !found ) coords[1] = j;
                if ( found && coords[0] == -1 ) break;
            }
            
            if ( coords[0] == -1 ) break;
            
            MapNode* mn = new MapNode();
            mn->seq = paths[i].path[ coords[0] ]->seq;
            
            for ( int j = coords[0]+1; j < coords[1]; j++ )
            {
                int ol;
                if ( paths[i].path[j-1]->edges[1] == paths[i].path[j] ) ol = paths[i].path[j-1]->ols[1];
                else  ol = paths[i].path[j]->ols[0];
                mn->seq += paths[i].path[j]->seq.substr( ol );
                assert( mn->seq.find( paths[i].path[j]->seq ) != mn->seq.npos );
            }
            
            iv.ev.bwt.mapSequence( mn->seq, mn->ids, mn->coords );
            mn->recoil();
            
            Node* node = new Node( mn, 0, mn->ids.size()-1, drxn+3 );
            iv.ev.island.push_back( node );
            ends.push_back( node );
            node->extendCount_ = 100;
            node->extendIsland( iv, drxn );
            node->extendCount_ = 100;
            node->extendIsland( iv, drxn );
        }
    }
    
    {
        NodeSet fwdSet;
        NodeSet bckSet;
        for ( Node* node : ends )
        {
            node->getDrxnNodes( fwdSet, drxn );
            node->getDrxnNodes( bckSet, !drxn );
        }
        for ( int i = 0; i < ends.size(); )
        {
            fwdSet.erase( ends[i] );
            if ( bckSet.find( ends[i] ) != bckSet.end() ) ends.erase( ends.begin() + i );
            else i++;
        }
        for ( Node* fwd : fwdSet )
        {
            if ( bckSet.find( fwd ) != bckSet.end() ) continue;
            iv.merged[drxn].erase( fwd );
            fwd->clearEdges( !drxn );
            fwd->dismantleNode();
            delete fwd;
            iv.ev.island.erase( remove( iv.ev.island.begin(), iv.ev.island.end(), fwd ), iv.ev.island.end() );
        }
    }
    
    NodeSet currSet;
    for ( Node* node : iv.ev.island ) if ( node->isContinue( !drxn ) ) currSet.insert( node );
    while ( !currSet.empty() )
    {
        for ( Node* isl : currSet )
        {
            if ( !isl->isContinue( !drxn ) ) continue;
            isl->extendCount_ = 99;
            isl->extendIsland( iv, !drxn );
            int pairCount = 0, readCount = 0;
            for ( Node* bck : isl->getDrxnNodes( !drxn, true, true ) )
            {
                readCount += bck->reads_.size();
                for ( ReadMark &mark : isl->marks_[drxn] )
                {
                    for ( Node* t : iv.ev.nodes )
                    {
                        auto it = t->reads_.find( mark.id );
                        if ( it == t->reads_.end() ) continue;
                        if ( abs( it->second[drxn] - ends_[drxn] ) < params.maxMpMean ) pairCount++;
                    }
                }
            }
            if ( pairCount || readCount < 200 ) continue;
//            for ( Node* bck : isl->getDrxnNodes( !drxn, true, true ) )
//            {
//                if ( bck->isContinue( !drxn ) ) bck->stop( 2, !drxn );
//            }
        }
        currSet.clear();
        for ( Node* node : iv.ev.island ) if ( node->isContinue( !drxn ) ) currSet.insert( node );
    }
    
    {
        int minCoord = 0;
        for ( Node* isl : iv.ev.island ) minCoord = min( minCoord, isl->ends_[0] );
        for ( Node* node : ends )
        {
            node->offsetForward( !drxn, true );
        }
        ofstream fp( "/media/glen/ssd/SpBACs/Clone47.fa" );
        for ( Node* mn : iv.ev.nodes )
        {
            fp << ">main" << endl << string( mn->ends_[0] - minCoord, '-' ) + mn->seq_ << endl;
        }
        for ( Node* isl : iv.ev.island )
        {
            fp << ">isl" << endl << string( isl->ends_[0] + ends_[1] - minCoord, '-' ) + isl->seq_ << endl;
        }
        fp.close();
        int x = 0;
    }
    
    NodeList mergeNodes( iv.merged[!drxn].begin(), iv.merged[!drxn].end() );
    for ( Node* merge : mergeNodes )
    {
        NodeList tNodes, qNodes;
        NodeSet bckSet = merge->getDrxnNodes( !drxn );
        int qScore = 0, tScore = 0, qtScore = 0;
        for ( Node* node : iv.ev.nodes ) ( bckSet.find( node ) != bckSet.end() ? tNodes : qNodes ).push_back( node );
        for ( Node* fwd : merge->getDrxnNodes( drxn, true, true ) )
        {
            for ( ReadMark &mark : fwd->marks_[drxn] )
            {
                for ( Node* t : tNodes ) tScore += t->reads_.find( mark.id ) != t->reads_.end();
                for ( Node* q : qNodes ) qtScore += q->reads_.find( mark.id ) != q->reads_.end();
            }
        }
        for ( Node* q : qNodes )
        {
            for ( ReadMark &mark : q->marks_[drxn] )
            {
                for ( Node* t : tNodes ) qScore += t->reads_.find( mark.id ) != t->reads_.end();
            }
        }
        if ( qScore + qtScore > tScore )
        {
//            ofstream fp( "/media/glen/ssd/SpBACs/Clone42.fa" );
//            for ( Node* con : merge->getConnectedNodes( false ) )
//            {
//                string seq = con->seq_;
//                revComp( seq );
//                fp << ">Clone42" << endl << seq << endl;
////                fp << ">Clone42" << endl << string( max( 0, con->ends_[0] ), '-' ) + seq << endl;
//            }
//            fp.close();
            iv.merged[!drxn].erase( merge );
            iv.merged[drxn].erase( merge );
            merge->dismantleNode();
            delete merge;
            iv.ev.island.erase( remove( iv.ev.island.begin(), iv.ev.island.end(), merge ), iv.ev.island.end() );
            ends.erase( remove( ends.begin(), ends.end(), merge ), ends.end() );
        }
    }
    
    assert( iv.merged[drxn].empty() );
    if ( !iv.merged[!drxn].empty() )
    {
        NodeSet fwdSet = iv.merged[!drxn], bckSet;
        for ( Node* merge : iv.merged[!drxn] ) merge->getDrxnNodes( fwdSet, drxn );
        for ( Node* fwd : fwdSet )
        {
            if ( fwd->drxn_ <= 2 ) continue;
            iv.ev.island.erase( remove( iv.ev.island.begin(), iv.ev.island.end(), fwd ), iv.ev.island.end() );
            ends.erase( remove( ends.begin(), ends.end(), fwd ), ends.end() );
            iv.ev.nodes.push_back( fwd );
            fwd->drxn_ = drxn;
            fwd->getDrxnNodes( bckSet, !drxn );
        }
        
        for ( int i = 0; i < iv.ev.island.size(); )
        {
            if ( fwdSet.find( iv.ev.island[i] ) == fwdSet.end() && bckSet.find( iv.ev.island[i] ) != bckSet.end() )
            {
                iv.ev.island[i]->dismantleNode();
                delete iv.ev.island[i];
                iv.ev.island.erase( iv.ev.island.begin() + i );
            }
            else i++;
        }
        
        iv.merged[!drxn].clear();
        
        return true;
    }
    
    NodeIntMap scores;
    for ( Node* node : iv.ev.island )
    {
        int score = 0;
        for ( ReadMark &mark : node->marks_[drxn] )
        {
            for ( Node* t : iv.ev.nodes )
            {
                auto it = t->reads_.find( mark.id );
                if ( it == t->reads_.end() ) continue;
                if ( abs( it->second[drxn] - ends_[drxn] ) > params.maxMpMean + 1500 ) continue;;
                score++;
                break;
            }
        }
        scores[node] = score;
    }
    
    NodeSet goodSet;
    for ( Node* node : ends )
    {
        if ( !node->edges_[drxn].empty() ) continue;
        node->offsetForward( !drxn, true );
        goodSet.insert( node );
        Node* curr = node;
        while ( curr && !curr->edges_[!drxn].empty() && curr->drxn_ > 2 )
        {
            Node* best = NULL;
            int bestScore;
            for ( Node* nxt : curr->getNextNodes( !drxn ) )
            {
                int score = scores[nxt];
                for ( Node* fwd : nxt->getDrxnNodes( !drxn ) ) score += scores[fwd];
                if ( !best || score > bestScore )
                {
                    best = nxt;
                    bestScore = score;
                }
            }
            if ( best ) goodSet.insert( best );
            curr = best;
        }
    }
    
    for ( int i = 0; i < iv.ev.island.size(); )
    {
        if ( goodSet.find( iv.ev.island[i] ) == goodSet.end() )
        {
            iv.ev.island[i]->dismantleNode();
            delete iv.ev.island[i];
            iv.ev.island.erase( iv.ev.island.begin() + i );
        }
        else i++;
    }
    
    return false;
}

void Node::fixSeedGetPairs( Querier &bwt, vector<GoodPair> &gps, vector<BadPair> &bps, bool drxn )
{
    NodeList tNodes = { this };
    for ( Node* bck : getDrxnNodes( !drxn ) ) tNodes.push_back( bck );
    
    for ( Node* q : tNodes )
    {
        if ( abs( q->ends_[drxn] - ends_[drxn] > params.maxMpMean ) ) continue;
        for ( ReadMark &mark : q->marks_[!drxn] )
        {
            bool found = false;
            for ( Node* t : tNodes )
            {
                auto it = reads_.find( mark.id );
                if ( it != reads_.end() )
                {
                    GoodPair gp( mark.mark, it->second[drxn], drxn, params.isReadPe( mark.id ) );
                    if ( gp.coords[0] < gp.coords[1] && q == this ) gps.push_back( gp );
                    found = true;
                    break;
                }
            }

            if ( found ) continue;
            if ( drxn ? mark.estimate < ends_[1] - 1000 : ends_[0] + 1000 < mark.estimate ) continue;

            BadPair bp;
            bp.id = mark.id;
            bp.ests[!drxn] = mark.mark;
            bp.ests[drxn] = mark.estimate;
            bp.seq = bwt.getSequence( mark.id );
            for ( Node* t : tNodes )
            {
                size_t hit = t->seq_.find( bp.seq );
                if ( hit != t->seq_.npos )
                {
                    GoodPair gp( mark.mark, t->ends_[0] + hit + ( drxn ? bp.seq.length() : 0 ), drxn, params.isReadPe( mark.id ) );
                    if ( gp.coords[0] < gp.coords[1] && q == this ) gps.push_back( gp );
                    found = true;
                    break;
                }
            }

            if ( found || q->drxn_ == 2 ) continue;

            bps.push_back( bp );
        }
    }
}

vector<PairPath> Node::fixSeedGraphPairs( vector<BadPair> &bps, bool drxn )
{
    for ( BadPair &bp1 : bps )
    {
        bp1.ols[1] = params.readLen / 2;
        if ( bp1.redundant ) continue;
        for ( BadPair &bp2 : bps )
        {
            if ( &bp1 == &bp2 ) continue;
            if ( bp2.seq == bp1.seq ) bp2.redundant = true;
            if ( bp2.redundant ) continue;
            int ol = mapSeqOverlap( bp1.seq, bp2.seq, bp1.ols[1] + 1 );
            if ( ol )
            {
                bp1.edges[1] = &bp2;
                bp1.ols[1] = ol;
                if ( !bp2.edges[0] || ol > bp2.ols[0] )
                {
                    bp2.edges[0] = &bp1;
                    bp2.ols[0] = ol;
                }
            }
        }
    }
    
    vector<BadPair*> ends[2];
    for ( BadPair &bp : bps )
    {
        for ( bool d : { 0, 1 } )
        {
            if ( !bp.edges[d] && bp.edges[!d] )
            {
                if ( bp.edges[!d]->edges[d] != &bp || !bp.edges[!d]->edges[!d] )
                {
                    bp.edges[!d] = NULL;
                }
                else
                {
                    ends[d].push_back( &bp );
                }
            }
        }
    }
    
    vector<PairPath> paths;
    unordered_set<BadPair*> used;
    for ( bool d : { 0, 1 } )
    {
        for ( BadPair* bp : ends[d] )
        {
            PairPath path;
            path.path.push_back( bp );
            path.olTotal = 0;
            bool loop = false;
            while ( path.path.back()->edges[!d] && !loop ) 
            {
                path.olTotal += path.path.back()->ols[!d];
                loop = find( path.path.begin(), path.path.end(), path.path.back()->edges[!d] ) != path.path.end();
                path.path.push_back( path.path.back()->edges[!d] );
            }
            if ( loop ) continue;
            if ( d ) reverse( path.path.begin(), path.path.end() );
            if ( path.olTotal < params.readLen * 10 || path.path.size() < 10 ) continue;
            path.path.erase( path.path.begin(), path.path.begin() + 4 );
            path.path.erase( path.path.end() - 4, path.path.end() );
            if ( used.find( path.path[0] ) != used.end() && used.find( path.path.back() ) != used.end() ) continue;
            used.insert( path.path.begin(), path.path.end() );
            
            paths.push_back( path );
        }
    }
    
    sort( paths.begin(), paths.end(), []( PairPath &a, PairPath &b ){
        return a.olTotal > b.olTotal;
    });
    
    return paths;
}

bool Node::fixSeedSetEdge( IslandVars &iv, vector<GoodPair> &gps, bool drxn )
{
    Node* best = NULL;
    NodeList starts;
    for ( Node* node : iv.ev.island )
    {
        if ( !node->edges_[!drxn].empty() && iv.merged[!drxn].find( node ) == iv.merged[!drxn].end() ) continue;
        starts.push_back( node );
        node->offsetForward( drxn );
        vector<int32_t> offsets, hits;
        for ( Node* fwd : node->getDrxnNodes( drxn, true, true ) )
        {
            for ( ReadMark &mark : fwd->marks_[drxn] )
            {
                for ( Node* t : iv.ev.nodes )
                {
                    auto it = t->reads_.find( mark.id );
                    if ( it == t->reads_.end() ) continue;
                    offsets.push_back( it->second[!drxn] - mark.estimate );
                    hits.push_back( it->second[drxn] );
                }
            }
        }
        if ( offsets.size() < 50 ) continue;
        sort( hits.begin(), hits.end() );
        sort( offsets.begin(), offsets.end() );
        int32_t offset = offsets[ offsets.size() / 2 ];
        node->offset( offset );
        node->offsetForward( drxn );
//        if ( 61700 < offset && offset < 61900 ) continue;
        if ( !best || abs( best->ends_[!drxn] - ends_[drxn] ) > abs( node->ends_[!drxn] - ends_[drxn] ) )
        {
            best = node;
        }
        if ( node->ends_[0] < ends_[1] - 500 )
        {
            int i = 0;
            while ( i < hits.size() && hits[i] < node->ends_[0] - params.maxMpMean - 1000 ) i++;
            hits.erase( hits.begin(), hits.begin() + i );
            i = 0;
            while ( i < hits.size() && hits[i] < node->ends_[0] + 100 ) i++;
            hits.erase( hits.begin() + i, hits.end() );
            if ( hits.empty() ) continue;
            int mainHits = 0;
            for ( GoodPair &gp : gps ) if ( gp.coords[0] < hits.back() && hits.back() < gp.coords[1] ) mainHits++;
            if ( node->ends_[0] < ends_[0] ) continue;
            ofstream fp( "/media/glen/ssd/test.fa" );
            fp << ">main" << endl << seq_ << endl << ">alt" << endl << string( node->ends_[0] - ends_[0], '-' ) << node->seq_ << endl;
            fp.close();
            int x = 0;
        }
    }
    
    if ( !best ) return false;
    
    Node* curr = best;
    NodeSet goodSet = { curr }, delSet;
    while ( curr && !curr->edges_[drxn].empty() )
    {
        if ( curr->edges_[drxn].size() > 1 )
        {
            curr->getDrxnNodes( delSet, drxn );
            for ( Node* nxt : curr->getNextNodes( drxn ) )
            {
                nxt->dismantleNode( delSet, drxn );
            }
        }
        else curr = curr->edges_[drxn][0].node;
        goodSet.insert( curr );
    }
    
    NodeList nodes[3];
    for ( int i = 0; i < iv.ev.island.size(); )
    {
        if ( delSet.find( iv.ev.island[i] ) != delSet.end() )
        {
            delete iv.ev.island[i];
            iv.ev.island.erase( iv.ev.island.begin() + i );
        }
        else if ( goodSet.find( iv.ev.island[i] ) != goodSet.end() )
        {
            iv.ev.island[i]->drxn_ = drxn;
            nodes[drxn].push_back( iv.ev.island[i] );
            iv.ev.island.erase( iv.ev.island.begin() + i );
        }
        else if ( iv.merged[0].find( iv.ev.island[i] ) != iv.merged[0].end()
                || iv.merged[1].find( iv.ev.island[i] ) != iv.merged[1].end() )
        {
            assert( false );
            iv.ev.island[i]->dismantleNode();
            delete iv.ev.island[i];
            iv.ev.island.erase( iv.ev.island.begin() + i );
        }
        else i++;
    }
    
    Node::mergeAll( nodes, delSet );
    best = NULL;
    for ( Node* node : nodes[drxn] )
    {
        if ( delSet.find( node ) != delSet.end() )
        {
            node->dismantleNode();
            delete node;
            iv.ev.nodes.erase( remove( iv.ev.nodes.begin(), iv.ev.nodes.end(), node ), iv.ev.nodes.end() );
        }
        else
        {
            assert( !best );
            node->remap( iv.ev.bwt );
            best = node;
        }
    }
    
    Node* edge = NULL;
    nodes[drxn].clear();
    delSet.clear();
    for ( Node* node : iv.ev.nodes ) if ( node->drxn_ != 2 ) nodes[drxn].push_back( node );
    Node::mergeAll( nodes, delSet );
    for ( Node* node : nodes[drxn] )
    {
        if ( delSet.find( node ) != delSet.end() )
        {
            node->dismantleNode();
            delete node;
            iv.ev.nodes.erase( remove( iv.ev.nodes.begin(), iv.ev.nodes.end(), node ), iv.ev.nodes.end() );
        }
        else
        {
            if ( edge )
            {
                NodeSet bckSet = edge->getDrxnNodes( !drxn );
                if ( bckSet.find( node ) != bckSet.end() ) continue;
            }
            edge = node;
        }
    }
    
    int32_t limits[2] = { best->ends_[0], best->ends_[0] };
    for ( auto &read : best->reads_ )
    {
        if ( abs( best->ends_[!drxn] - read.second[drxn] ) > params.readLen + 100 ) continue;
        addRead( read.first
                , edge->ends_[1] + 10 + read.second[0] - best->ends_[0]
                , edge->ends_[1] + 10 + read.second[1] - best->ends_[0]
                , read.second.redundant );
        limits[0] = min( limits[0], read.second[0] );
        limits[1] = max( limits[1], read.second[1] );
    }
    edge->seq_ += string( 10, 'N' ) + best->seq_.substr( 0, limits[1] - limits[0] );
    edge->ends_[1] = edge->ends_[0] + edge->seq_.length();
//    for ( auto &read : best->reads_ )
//    {
//        addRead( read.first
//                , edge->ends_[1] + 10 + read.second[0] - best->ends_[0]
//                , edge->ends_[1] + 10 + read.second[1] - best->ends_[0]
//                , read.second.redundant );
//    }
//    edge->seq_ += string( 10, 'N' ) + best->seq_;
//    edge->ends_[1] = edge->ends_[0] + edge->seq_.length();
    best->setCoverage();
    best->dismantleNode();
    edge->stop_[drxn] = 0;
    delete best;
    iv.merged[0].clear();
    iv.merged[1].clear();
    
    return true;
}

bool Node::isSeed( int32_t seedLen )
{
    return validLimits_[0] < ends_[1] && 0 < ends_[1] && ends_[0] < validLimits_[3] && ends_[0] < seedLen;
}

bool Node::plotSeed( IslandVars &iv, NodeSet &delSet, bool drxn, bool finished )
{
    Node* curr = this;
    Node* base = NULL;
    for ( Node* node : iv.ev.nodes ) if ( node->drxn_ == 2 ) base = node;
    offsetForward( drxn );
    while ( curr )
    {
        int ol = mapSeqOverlap( curr->seq_, base->seq_, 80 );
        if ( ol && curr->drxn_ != 2 )
        {
            curr->trimEnd( curr->ends_[1] - ol, iv.ev.nodes, 1 );
            return true;
        }
        
        int32_t furthest = curr->ends_[drxn];
        int fwdCount = 0;
        for ( Node* fwd : curr->getDrxnNodes( drxn ) )
        {
            fwdCount++;
            furthest = drxn ? max( furthest, fwd->ends_[1] ) : min( furthest, fwd->ends_[0] );
        }
        if ( !finished && abs( curr->ends_[drxn] - furthest ) < 1000 && fwdCount < 15 ) break;
        
        NodeOffsetMap maps[2] = { curr->getDrxnNodesOffset( 0, 0, true )
                                , curr->getDrxnNodesOffset( 1, 0, true ) };
        
        NodeSet sharedSet;
        NodeList nxtNodes;
        NodeSetList fwdSets;
        {
            NodeSet fwdSet;
            for ( Node* nxt : curr->getNextNodes( drxn ) )
            {
                nxtNodes.push_back( nxt );
                NodeSet nxtFwdSet = nxt->getDrxnNodes( drxn, false, true );
                fwdSets.push_back( nxtFwdSet );
                for ( Node* fwd : nxtFwdSet )
                {
                    if ( fwdSet.find( fwd ) != fwdSet.end() ) sharedSet.insert( fwd );
                    else fwdSet.insert( fwd );
                }
            }
        }
        
        bool isOffset = false;
        for ( Node* node : sharedSet )
        {
            for ( Node* prv : node->getNextNodes( !drxn ) )
            {
                if ( sharedSet.find( prv ) != sharedSet.end() ) continue;
                auto it = maps[drxn].find( prv );
                if ( it == maps[drxn].end() || it->second.second - it->second.first < 200 ) continue;
                isOffset = true;
            }
        }
        if ( isOffset ) sharedSet.clear();
        
        NodeList tNodes;
        for ( auto it : maps[!drxn] )
        {
            tNodes.push_back( it.first );
        }
        int bestScores[2];
        int iBest = 0;
        for ( int i = 0; i < nxtNodes.size(); i++ )
        {
            maps[drxn] = nxtNodes[i]->getDrxnNodesOffset( drxn, 0, true );
            maps[!drxn] = nxtNodes[i]->getDrxnNodesOffset( !drxn, 0, true );
            int score = 0;
            int bad = 0;
            int readCount = 0;
            for ( Node* fwd : fwdSets[i] )
            {
                auto itMap = maps[drxn].find( fwd );
                if ( itMap == maps[drxn].end() || sharedSet.find( fwd ) != sharedSet.end() ) continue;
                int fwdOff[2] = { itMap->second.first, itMap->second.second };
                for ( ReadMark &mark : fwd->marks_[drxn] )
                {
                    readCount += ( mark.estimate < curr->ends_[1] );
                    int best = 2000;
                    bool anyHit = false;
                    for ( Node* t : tNodes )
                    {
                        auto it = t->reads_.find( mark.id );
                        if ( it == t->reads_.end() ) continue;
                        int off = mark.estimate - it->second[!drxn];
                        auto itMap = maps[!drxn].find( t );
                        int tOff[2] = { itMap->second.first, itMap->second.second };
                        if ( off > 0 )
                        {
                            off = max( 0, off - ( drxn ? fwdOff[1] + tOff[0] : tOff[1] + fwdOff[0] ) );
                        }
                        else
                        {
                            off = min( 0, off + ( drxn ? fwdOff[0] + tOff[1] : tOff[0] + fwdOff[1] ) );
                        }
                        off = abs( off );
                        if ( !anyHit || off < best ) best = off;
                        anyHit = true;
                    }
                    if ( params.isReadPe( mark.id ) ? best < 200 : best < 1500 ) score++;
                    else bad += anyHit;
                }
            }
            
            if ( !i || score > bestScores[1] || score == bestScores[1] && bad < bestScores[0] )
            {
                iBest = i;
                bestScores[1] = score;
                bestScores[0] = bad;
            }
        }
        for ( int i = 0; i < nxtNodes.size(); i++ )
        {
            if ( i == iBest ) continue;
            nxtNodes[i]->dismantleNode( delSet, drxn );
        }
        curr = nxtNodes.empty() ? NULL : nxtNodes[iBest];
    }
    offsetForward( drxn );
    
    return false;
}

void Node::plotSeed( NodeList &ends, bool drxn )
{
    struct SeedBranch
    {
        SeedBranch( Edge &e, NodeList &tNodes, NodeSet &shared, bool drxn )
        : n( e.node ), ol( e.overlap )
        {
            score[0] = score[1] = reads = 0;
            for ( Node* fwd : e.node->getDrxnNodes( drxn, false, true ) )
            {
                reads += fwd->reads_.size();
                for ( ReadMark &mark : fwd->marks_[drxn] )
                {
                    for ( Node* t : tNodes )
                    {
                        if ( t->reads_.find( mark.id ) == t->reads_.end() ) continue;
                        score[ shared.find( t ) != shared.end() ]++;
                    }
                }
            }
        }
        bool operator>( SeedBranch &rhs )
        {
            if ( score[0] > rhs.score[0] ) return true;
            else if ( score[0] < rhs.score[1] ) return false;
            else if ( score[1] > rhs.score[1] ) return true;
            else if ( score[1] < rhs.score[1] ) return false;
            else if ( ol > rhs.ol ) return true;
            else if ( ol < rhs.ol ) return false;
            else if ( reads < rhs.reads ) return false;
            return true;
        }
        Node* n;
        int ol, score[2], reads;
    };
    struct SeedPath
    {
        SeedPath( Node* node, bool drxn )
        : ended( false )
        {
            path.push_back( node );
        }
        NodeList path;
        NodeListList alts, starts;
        NodeSet shared;
        bool ended;
    };
    vector<SeedPath> paths;
    for ( Node* node : ends ) paths.push_back( SeedPath( node, drxn ) );
    
    bool complete = false;
    while ( !complete )
    {
        complete = true;
        for ( SeedPath &path : paths )
        {
            if ( path.ended ) continue;
            complete = false;
            NodeSet altFwd;
            for ( SeedPath &altPath : paths )
            {
                if ( &path == &altPath ) continue;
                altFwd.insert( altPath.path.back() );
                altPath.path.back()->getDrxnNodes( altFwd, drxn );
            }
            NodeList tNodes( path.path.begin(), path.path.end() );
            NodeList branches;
            NodeSetList branchFwd;
            while ( !path.ended && altFwd.find( path.path.back() ) == altFwd.end() )
            {
                vector<SeedBranch*> edges;
                SeedBranch* edge = NULL;
                for ( Edge &e : path.path.back()->edges_[drxn] )
                {
                    SeedBranch* branch = new SeedBranch( e, tNodes, path.shared, drxn );
                    edges.push_back( branch );
                    if ( !edge || *branch > *edge ) edge = branch;
                }
                if ( !edge ) path.ended = true;
                else
                {
                    for ( int i = 0; i < branches.size(); )
                    {
                        if ( branches[i] == edge->n )
                        {
                            branches.erase( branches.begin() + i );
                            branchFwd.erase( branchFwd.begin() + i );
                        }
                        else if ( branchFwd[i].find( edge->n ) != branchFwd[i].end() )
                        {
                            NodeSet pathSet = edge->n->getDrxnNodesInSet( branchFwd[i], !drxn, true );
                            NodeList allele;
                            Node* curr = branches[i];
                            while ( curr && altFwd.find( curr ) == altFwd.end() )
                            {
                                allele.push_back( curr );
                                SeedBranch* branch = NULL;
                                for ( Edge &e : curr->edges_[drxn] )
                                {
                                    if ( pathSet.find( e.node ) == pathSet.end() || altFwd.find( curr ) != altFwd.end() ) continue;
                                    SeedBranch* edgeBranch = new SeedBranch( e, tNodes, path.shared, drxn );
                                    if ( !branch || *edgeBranch > *branch )
                                    {
                                        if ( branch ) delete branch;
                                        branch = edgeBranch;
                                    }
                                    else delete edgeBranch;
                                }
                                curr = NULL;
                                if ( branch )
                                {
                                    curr = branch->n;
                                    delete branch;
                                }
                            }
                            for ( Node* node : allele )
                            {
                                if ( find( tNodes.begin(), tNodes.end(), node ) == tNodes.end() ) tNodes.push_back( node );
                            }
                            path.alts.push_back( allele );
                            branches.erase( branches.begin() + i );
                            branchFwd.erase( branchFwd.begin() + i );
                        }
                        else i++;
                    
                    }
                    path.path.push_back( edge->n );
                    bool looped = false;
                    for ( int i = 0; i < path.path.size()-1; i++ )
                    {
                        if ( path.path[i] != edge->n ) continue;
                        looped = true;
                        SeedBranch* branch = NULL;
                        NodeList branchPath;
                        for ( int j = i; j < path.path.size()-1; j++ )
                        {
                            for ( Edge &e: path.path[j]->edges_[drxn] )
                            {
                                for ( int k = 0; k < branches.size(); )
                                {
                                    if ( e.node == branches[k] )
                                    {
                                        branches.erase( branches.begin() + k );
                                        branchFwd.erase( branchFwd.begin() + k );
                                    }
                                    else k++;
                                }
                                if ( find( tNodes.begin(), tNodes.end(), e.node ) != tNodes.end() ) continue;
                                SeedBranch* edgeBranch = new SeedBranch( e, tNodes, path.shared, drxn );
                                if ( !branch || *edgeBranch > *branch )
                                {
                                    if ( branch ) delete branch;
                                    branch = edgeBranch;
                                    branchPath = { path.path.begin() + i, path.path.begin() + j };
                                    branchPath.push_back( branch->n );
                                }
                                else delete edgeBranch;
                            }
                        }
                        if ( branch )
                        {
                            path.path.insert( path.path.end(), branchPath.begin(), branchPath.end() );
                            delete branch;
                        }
                        else path.ended = true;
                        break;
                    }
                    if ( find( tNodes.begin(), tNodes.end(), edge->n ) == tNodes.end() ) tNodes.push_back( edge->n );
                    for ( SeedBranch* e : edges )
                    {
                        if ( !looped && e != edge && altFwd.find( e->n ) == altFwd.end() )
                        {
                            branches.push_back( e->n );
                            branchFwd.push_back( e->n->getDrxnNodes( drxn, false, true ) );
                        }
                        delete e;
                    }
                }
            }
            
        }
    }
}

void Node::seedAdd( ReadStruct &read )
{
    int32_t diff = read.coords[1] - ends_[1];
    if ( diff >= 0 )
    {
        validLimits_[2] = validLimits_[3] = read.tether[1];
        seq_ += read.seq.substr( read.seq.length() - diff );
        ends_[1] += diff;
    }
    else
    {
        assert( false );
    }
    reads_.insert( make_pair( read.readId, Coords( read.coords[0], read.coords[1], diff < 0 ) ) );
}

bool Node::seedCongruent( ReadStruct &read, int32_t &coord )
{
    bool congruent = read.tether[0] == read.coords[0] && validLimits_[0] <= read.tether[0] && read.tether[0] < validLimits_[3];
    bool maybe = read.tether[0] <= validLimits_[0];
    coord = min( read.tether[1], validLimits_[3] );
    
    if ( !congruent && maybe )
    {
        congruent = true;
        int32_t diff = read.coords[0] - ends_[0];
        int32_t len = max( read.tether[0], validLimits_[0] ) - read.coords[0];
        for ( int i( 0 ); i < len; i++ )
        {
            congruent = congruent && seq_[i+diff] == read.seq[i];
        }
    }
    
    while( congruent && coord != ends_[1] && seq_[coord - ends_[0]] == read.seq[coord - read.coords[0]] )
    {
        coord++;
    }
    
    if ( congruent && coord != ends_[1] )
    {
        congruent = false;
        for ( auto &read : reads_ )
        {
            congruent = congruent || read.second[1] <= coord;
        }
    }
    
    return congruent;
}

bool Node::seedDiminutive()
{
    int readCount = 0;
    for ( auto &read : reads_ ) if ( !read.second.redundant 
            && read.second[1] - read.second[0] > params.readLen * 0.8 ) readCount++;
    if ( readCount > 1 ) return false;
    int ols[2] = { getBestOverlap( 0 ), getBestOverlap( 1 ) };
    if ( ols[0] + ols[1] > seq_.length() ) return false;
    if ( ( !ols[0] || !ols[1] ) && ( max( ols[0], ols[1] ) > params.readLen / 2 ) ) return false;
    for ( bool drxn : { 0, 1 } )
    {
        bool better = edges_[drxn].empty();
        for ( Node* nxt : getNextNodes( drxn ) )
        {
            if ( nxt->edges_[!drxn].size() == 1 ) return false;
            for ( Edge &e : nxt->edges_[!drxn] )
            {
                if ( e.overlap < params.readLen / 2 || e.overlap <= ols[drxn] ) continue;
                int eReadCount = 0;
                for ( auto &read : e.node->reads_ ) if ( !read.second.redundant 
                        && read.second[1] - read.second[0] > params.readLen * 0.8 ) eReadCount++;
                if ( e.overlap + e.node->getBestOverlap( !drxn ) > seq_.length() || eReadCount > 5 ) better = true;
            }
        }
        
        if ( !better ) return false;
    }
    
    return true;
}

void Node::seedGetExtend( NodeList* extendNodes, NodeSet &seedSet, NodeSet &delSet, int32_t* limits )
{
    for ( int drxn : { 0, 1 } )
    {
        NodeSet currSet = seedSet;
        NodeIntMap edgeMap;
        
        while( !currSet.empty() )
        {
            NodeSet nxtSet;
            NodeSet currFwd;
            for ( Node* curr : currSet )
            {
                curr->getDrxnNodes( currFwd, drxn );
            }
            
            for ( Node* curr : currSet )
            {
                if ( currFwd.find( curr ) != currFwd.end() )
                {
                    nxtSet.insert( curr );
                }
                else
                {
                    int edgeCount = 8 + curr->edges_[!drxn].size();

                    for ( Node* bck : curr->getNextNodes( !drxn ) )
                    {
                        auto it = edgeMap.find( bck );
                        edgeCount = it != edgeMap.end() ? min( edgeCount, it->second ) : edgeCount;
                    }
                    
                    edgeCount = seedSet.find( curr ) != seedSet.end() ? curr->edges_[!drxn].size() : edgeCount;
                    edgeCount += curr->edges_[drxn].size() - curr->edges_[!drxn].size();
                    
                    if ( edgeCount < 8 && ( drxn ? curr->ends_[1] < limits[1] : limits[0] < curr->ends_[0] ) )
                    {
                        if ( curr->isContinue( drxn ) && !curr->clones_ )
                        {
                            extendNodes[drxn].push_back( curr );
                        }
                        curr->getNextNodes( nxtSet, drxn );
                    }

                    edgeMap[curr] = edgeCount;
                }
            }
            currSet = nxtSet;
        }
    }
}

bool Node::seedJoin( Node* node, int32_t coord, bool drxn )
{
//    for ( bool d : { 0, 1 } )
//    {
//        bool anyOrigin = false;
//        NodeSet bckSet = ( d == drxn ? this : node )->getDrxnNodes( !d, false, true );
//        for ( Node* bck : bckSet )
//        {
//            anyOrigin = anyOrigin || bck->drxn_ == 2;
//        }
//        if ( !anyOrigin )
//        {
//            int x = 0;
//            for ( Node* bck : bckSet )
//            {
//                bck->drxn_ = !d;
//            }
//            assert( false );
//            return;
//        }
//    }
    
    NodeSet bckSet = node->getDrxnNodes( !drxn );
    for ( Node* bck : getDrxnNodes( !drxn ) )
    {
        assert( bckSet.find( bck ) == bckSet.end() );
    }
    
    if ( drxn ? ends_[1] <= coord + 100 : coord - 100 <= ends_[0] )
    {
        Node* fwdNode = ( drxn ? node : this );
        
        NodeSet fwdSet = fwdNode->getDrxnNodes( 1, false, true );
        NodeSet revSet;

        for ( Node* fwd : fwdSet )
        {
            fwd->drxn_ = 1;
        }

        for ( Node* connected : fwdNode->getConnectedNodes( false ) )
        {
            if ( connected->drxn_ == 2 )
            {
                revSet.insert( connected );
                connected->getDrxnNodes( revSet, 0 );
            }
        }

        for ( Node* fwd : fwdNode->getDrxnNodes( 1, false, true ) )
        {
            fwdSet.insert( fwd );
            fwd->getDrxnNodesNotInSet( fwdSet, revSet, 0 );
        }

        for ( Node* fwd : fwdSet )
        {
            fwd->drxn_ = 1;
        }
        
        return true;
    }
    
    return false;
}

void Node::seedJoinLoci( Node** nodes )
{
    NodeSet fwdSets[2];
    NodeSet revSets[2];
    for ( bool drxn : { 0, 1 } )
    {
        fwdSets[drxn] = nodes[drxn]->getDrxnNodes( drxn, false, true );
    }
    
    for ( bool drxn : { 0, 1 } )
    {
        for ( Node* node : fwdSets[drxn] )
        {
            for ( Node* prv : node->getNextNodes( !drxn ) )
            {
                if ( fwdSets[drxn].find( prv ) == fwdSets[drxn].end()
                        && revSets[drxn].find( prv ) == revSets[drxn].end() )
                {
                    revSets[drxn].insert( prv );
                    prv->getDrxnNodesNotInSet( revSets[drxn], fwdSets[!drxn], !drxn );
                }
            }
        }
    }
    
    assert( false );
}

bool Node::seedLeap( Querier &bwt, NodeList &nodes, int minCoord, int maxCoord )
{
    struct BadPair
    {
        BadPair():redundant( false ){ edges[0] = edges[1] = NULL; };
        ReadId id;
        string seq;
        BadPair* edges[2];
        int ols[2], coord;
        bool redundant;
    };
    vector<BadPair> bps;
    
    for ( Node* n1 : nodes )
    {
        for ( bool drxn : { 0, 1 } )
        {
            for ( ReadMark &mark : n1->marks_[drxn] )
            {
                if ( mark.estimate < minCoord || maxCoord< mark.estimate ) continue;
                bool doGet = true;
                for ( Node* n2 : nodes )
                {
                    if ( n2->reads_.find( mark.id ) != n2->reads_.end() )
                    {
                        doGet = false;
                        break;
                    }
                }
                if ( !doGet ) continue;
                
                BadPair bp;
                bp.seq = bwt.getSequence( mark.id );
                bp.coord = drxn ? mark.estimate : mark.estimate - params.readLen;
                bps.push_back( bp );
            }
        }
    }
    
    for ( BadPair &bp1 : bps )
    {
        bp1.ols[1] = params.readLen / 2;
        if ( bp1.redundant ) continue;
        for ( BadPair &bp2 : bps )
        {
            if ( &bp1 == &bp2 ) continue;
            if ( bp1.seq.find( bp2.seq ) != bp1.seq.npos ) bp2.redundant = true;
            if ( bp2.redundant ) continue;
            if ( bp2.seq.find( bp1.seq ) != bp2.seq.npos ) bp1.redundant = true;
            if ( bp1.redundant ) break;
            int ol = mapSeqOverlap( bp1.seq, bp2.seq, bp1.ols[1] + 1 );
            if ( ol )
            {
                bp1.edges[1] = &bp2;
                bp1.ols[1] = ol;
                if ( !bp2.edges[0] || ol > bp2.ols[0] )
                {
                    bp2.edges[0] = &bp1;
                    bp2.ols[0] = ol;
                }
            }
        }
    }
    
    vector<BadPair*> ends[2];
    for ( BadPair &bp : bps )
    {
        for ( bool d : { 0, 1 } )
        {
            if ( !bp.edges[d] && bp.edges[!d] )
            {
                if ( bp.edges[!d]->edges[d] != &bp || !bp.edges[!d]->edges[!d] )
                {
                    bp.edges[!d] = NULL;
                }
                else
                {
                    ends[d].push_back( &bp );
                }
            }
        }
    }
    
    unordered_set<BadPair*> used;
    for ( bool d : { 0, 1 } )
    {
        for ( BadPair* bp : ends[d] )
        {
            vector<BadPair*> path = { bp };
            while ( path.back()->edges[!d] ) path.push_back( path.back()->edges[!d] );
            if ( d ) reverse( path.begin(), path.end() );
            string seq = path[0]->seq;
            for ( int i = 1; i < path.size(); i++ )
            {
                int ol = path[i-!d]->ols[!d];
                seq += path[i]->seq.substr( ol );
            }
            if ( used.find( path[0] ) != used.end() && used.find( path.back() ) != used.end() ) continue;
            used.insert( path.begin(), path.end() );
            MapNode* mn = new MapNode();
            mn->seq = seq.substr( 1, seq.length() - 2 );
            bwt.mapSequence( mn->seq, mn->ids, mn->coords );
            
            int i = 0;
            while ( i < mn->ids.size() )
            {
                bool found = false;
                for ( Node* node : nodes )
                {
                    if ( node->reads_.find( mn->ids[i] ) != node->reads_.end() ) found = true;
                }
                if ( found ) i++;
                else break;
            }
            mn->ids.erase( mn->ids.begin(), mn->ids.begin() + i );
            mn->coords[0].erase( mn->coords[0].begin(), mn->coords[0].begin() + i );
            mn->coords[1].erase( mn->coords[1].begin(), mn->coords[1].begin() + i );
            i = 0;
            while ( i < mn->ids.size() )
            {
                bool found = false;
                for ( Node* node : nodes )
                {
                    if ( node->reads_.find( mn->ids[i] ) != node->reads_.end() ) found = true;
                }
                if ( found ) break;
                else i++;
            }
            mn->ids.erase( mn->ids.begin() + i, mn->ids.end() );
            mn->coords[0].erase( mn->coords[0].begin() + i, mn->coords[0].end() );
            mn->coords[1].erase( mn->coords[1].begin() + i, mn->coords[1].end() );
            
            if ( !mn->ids.empty() )
            {
                mn->recoil();
                Node* node = new Node( mn, 0, mn->ids.size()-1, 1 );
                node->offset( path[0]->coord );
                nodes.push_back( node );
            }
            delete mn;
        }
    }
}

void Node::seedLoop( bool drxn )
{
    NodeSet fwdSet = getDrxnNodes( drxn );
    if ( fwdSet.find( this ) == fwdSet.end() ) return;
    NodeSet usedSet = { this };
    NodeSet loopSet = getDrxnNodesInSet( fwdSet, !drxn );
    for ( int i = 0; i < edges_[drxn].size(); )
    {
        if ( loopSet.find( edges_[drxn][i].node ) != loopSet.end()
                && edges_[drxn][i].node->seedLoop( loopSet, usedSet, edges_[drxn][i].node->seq_.length() - edges_[drxn][i].overlap, params.maxPeMax, drxn ) )
        {
            edges_[drxn][i].node->offsetNode( !drxn );
            edges_[drxn][i].node->removeEdge( this, 0 );
            edges_[drxn].erase( edges_[drxn].begin() + i );
        }
        else i++;
    }
    if ( isContinue( drxn ) ) stop_[drxn] = 1;
    int x = 0;
}

bool Node::seedLoop( NodeSet &loopSet, NodeSet &usedSet, int len, int limit, bool drxn )
{
    usedSet.insert( this );
    if ( len > limit ) return true;
    for ( Edge &e : edges_[drxn] )
    {
        if ( usedSet.find( e.node ) != usedSet.end() ) continue;
        if ( loopSet.find( e.node ) == loopSet.end() ) continue;
        if ( e.node->seedLoop( loopSet, usedSet, len + e.node->seq_.length() - e.overlap, limit, drxn ) ) return true;
    }
    return false;
}
    

void Node::seedSetDrxnNodes( Node* fork, NodeList &nodes, bool drxn )
{
    for ( Node* fwd : fork->getDrxnNodes( drxn ) )
    {
        fwd->drxn_ = drxn;
        fwd->validLimits_[0] = fwd->validLimits_[1];
        fwd->validLimits_[3] = fwd->validLimits_[2];
        if ( find ( nodes.begin(), nodes.end(), fwd ) == nodes.end() )
        {
            nodes.push_back( fwd );
        }
    }
    vector<Edge> edges;
    for ( Edge &e : fork->edges_[drxn] )
    {
        edges.push_back( e );
        e.node->removeEdge( fork, !drxn );
    }
    fork->edges_[drxn].clear();
    
    for ( Edge &e : edges )
    {
        addEdge( e.node, e.overlap, drxn );
    }
}

Node* Node::seedSetOrigin( NodeList &forkList )
{
    Node* node = new Node();
    node->drxn_ = 2;
    node->ends_[0] = forkList[0]->ends_[0];
    node->ends_[1] = forkList[0]->ends_[1];
    node->seq_ = forkList[0]->seq_;
    node->validLimits_[0] = forkList[0]->validLimits_[1];
    node->validLimits_[1] = forkList[0]->validLimits_[1];
    node->validLimits_[2] = forkList[0]->validLimits_[2];
    node->validLimits_[3] = forkList[0]->validLimits_[2];
    
    int readCount[forkList.size()];
    readCount[0] = forkList[0]->reads_.size();
    
    for ( auto &read : forkList[0]->reads_ )
    {
        node->reads_.insert( read );
    }
    
    int32_t offset = 0;
    for ( int i( 1 ); i < forkList.size(); i++ )
    {
        int32_t overlap = forkList[i-1]->getOverlap( forkList[i], 1 );
        offset += forkList[i]->ends_[0] - forkList[i-1]->ends_[1] + overlap;
        node->seq_ += forkList[i]->seq_.substr( overlap );
        for ( auto read : forkList[i]->reads_ )
        {
            read.second.offset( -offset );
            node->reads_.insert( read );
        }
        node->ends_[1] = forkList[i]->ends_[1] - offset;
        node->validLimits_[0] = min( node->validLimits_[0], forkList[i]->validLimits_[1] - offset );
        node->validLimits_[1] = min( node->validLimits_[1], forkList[i]->validLimits_[1] - offset );
        node->validLimits_[2] = max( node->validLimits_[2], forkList[i]->validLimits_[2] - offset );
        node->validLimits_[3] = max( node->validLimits_[3], forkList[i]->validLimits_[2] - offset );
        readCount[i] = forkList[i]->reads_.size();
    }
    
    int seqLen = node->seq_.length();
    assert( node->ends_[1] - node->ends_[0] == node->seq_.length() );
    node->setCoverage();
    int x = 0;
    
    return node;
}

void Node::seedSplit( NodeList &nodes, int32_t coord )
{
    Node* node = new Node();
    node->ends_[1] = node->ends_[0] = ends_[1];
    ends_[1] = ends_[0];
    for ( auto it = reads_.begin(); it != reads_.end(); )
    {
        if ( it->second[1] <= coord )
        {
            ends_[1] = max( ends_[1], it->second[1] );
            it++;
        }
        else
        {
            node->ends_[0] = min( node->ends_[0], it->second[0] );
            node->reads_.insert( *it );
            it = reads_.erase( it );
        }
    }
    
    node->validLimits_[2] = node->validLimits_[3] = max( validLimits_[3], node->ends_[0] );
    node->validLimits_[0] = node->validLimits_[1] = max( validLimits_[0], node->ends_[0] );
    validLimits_[2] = validLimits_[3] = min( validLimits_[3], ends_[1] );
    
    node->seq_ = seq_.substr( seq_.length() - ( node->ends_[1] - node->ends_[0] ) );
    seq_.erase( seq_.begin() + ( ends_[1] - ends_[0] ), seq_.end() );
    for ( Edge &e : edges_[1] )
    {
        node->addEdge( e.node, e.overlap, 1, false );
        e.node->removeEdge( this, 0 );
    }
    edges_[1].clear();
    node->addEdge( this, 0 );
    nodes.push_back( node );
}

void Node::seedValidate( NodeSet &seedSet, NodeSet &delSet, int32_t* validLimits, int32_t* ends, bool doDel )
{
    NodeList notValid[2] = { { seedSet.begin(), seedSet.end() }, { seedSet.begin(), seedSet.end() } };
    
    for ( bool drxn : { 0, 1 } )
    {
        NodeSet currSet = { notValid[drxn].begin(), notValid[drxn].end() };
        notValid[drxn].clear();
        while ( !currSet.empty() )
        {
            NodeSet nxtSet, currFwd;
            for ( Node* curr : currSet )
            {
                curr->getDrxnNodes( currFwd, drxn );
            }

            for ( Node* curr : currSet )
            {
                if ( curr->isDeadEnd( drxn ) && doDel )
                {
                    curr->dismantleNode( delSet, drxn );
                    seedSet.erase( curr );
                }
                else if ( currFwd.find( curr ) != currFwd.end() )
                {
                    nxtSet.insert( curr );
                }
                else if ( curr->validate( drxn ) )
                {
                    curr->getNextNodes( nxtSet, drxn );
                }
                else
                {
                    notValid[drxn].push_back( curr );
                }

                validLimits[drxn] = ( drxn ? max( validLimits[1], curr->validLimits_[2] )
                                      : min( validLimits[0], curr->validLimits_[1] ) );
            }

            currSet = nxtSet;
        }
    }
    
    if ( ends[1] - ends[0] > params.maxPeMean && doDel )
    {
        int cutoff = (params.maxPeMean * params.cover * 2 ) / params.readLen;
        for ( bool drxn : { 0, 1 } )
        {
            for ( Node* node : notValid[drxn] )
            {
                int misses = node->getEndMarks( drxn ) * 5;
                int hits = 2;
                int32_t endCoord = node->ends_[drxn];
                for ( Node* fwd : node->getDrxnNodes( drxn ) )
                {
                    endCoord = drxn ? max( endCoord, fwd->ends_[1] )
                                    : min( endCoord, fwd->ends_[0] );
                    misses += fwd->reads_.size();
                    hits += fwd->getPairHitsTotal();
                }
                
                if ( misses / hits > cutoff && hits < 4 )
                {
                    node->dismantleNode( delSet, drxn );
                }
            }
        }
    }
}

bool Node::seedValidate( bool drxn )
{
    if ( validated_ )
    {
        return true;
    }
    
    NodeList tNodes = this->getTargetNodes( drxn, true );
    NodeOffsetMap fwdMap = getDrxnNodesOffset( drxn, 0, true );
    NodeOffsetMap revMap = getDrxnNodesOffset( !drxn, 0, true );
    
    while ( seedValidate( tNodes, fwdMap, revMap, drxn ) );
    for ( Node* fwd : getDrxnNodes( drxn ) )
    {
        fwd->seedValidate( tNodes, fwdMap, revMap, drxn );
    }
    
    validated_ = validated_ || ( !isContinue( 0 ) && !isContinue( 1 ) && validLimits_[1] == ends_[0] && validLimits_[2] == ends_[1] );
    
    return ( drxn ? validLimits_[2] == ends_[1] : validLimits_[1] == ends_[0] );
}

bool Node::seedValidate( NodeList &tNodes, NodeOffsetMap &fwdMap, NodeOffsetMap &revMap, bool drxn )
{
    bool didPair = false;
    unordered_set<SeqNum> usedIds;
    NodeSet tSet = getDrxnNodes( !drxn ), hitSet;

    for ( ReadMark &mark : marks_[drxn] )
    {
        if ( drxn ? validLimits_[1] < mark.mark
                  : mark.mark < validLimits_[2] )
        {
            for ( Node* t : tNodes )
            {
                auto it = t->reads_.find( mark.id );
                if ( it != t->reads_.end()
                        && ( drxn ? it->second[1] <= t->validLimits_[2] : validLimits_[1] <= it->second[0] ) )
                {
                    didPair = true;
                    hitSet.insert( t );
                    usedIds.insert( mark.id );
                    pushValidLimits( mark.mark, drxn );
                    t->pushValidLimits( it->second[!drxn], !drxn );
                    NodeSet midSet = t->getDrxnNodesInSet( tSet, drxn );
                    auto r = pairs_.insert( make_pair( t, 1 ) );
                    if ( !r.second ) r.first->second++;
                    if ( this != t )
                    {
                        r = t->pairs_.insert( make_pair( this, 1 ) );
                        if ( !r.second ) r.first->second++;
                        pushValidLimits( ends_[!drxn], !drxn );
                        t->pushValidLimits( t->ends_[drxn], drxn );
                        for ( Node* node : midSet )
                        {
                            node->pushValidLimits( node->ends_[0], 0 );
                            node->pushValidLimits( node->ends_[1], 1 );
                        }
                    }
                }
            }
        }
    }

    for ( Node* node : hitSet )
    {
        node->removeMarks( usedIds, false, true, !drxn );
    }
    removeMarks( usedIds, false, false, drxn );
    
    return didPair;
}

void Node::seedValidate( NodeList &nodes, NodeSet &delSet, bool drxn )
{
//    while ( !currSet.empty() )
//    {
//        NodeSet nxtSet;
////        for ( Node* curr : currSet )
////        {
////            usedSet.insert( curr );
////            unordered_set<SeqNum> usedIds;
////            for ( Node* fwd : curr->getDrxnNodes( drxn, false, true ) )
////            {
////                for ( ReadMark &mark : curr->marks_[!drxn] )
////                {
////                    if ( fwd->reads_.find( mark.id ) == fwd->reads_.end() ) continue;
////                    usedIds.insert( mark.id );
////                    auto r = curr->pairs_.insert( make_pair( fwd, 1 ) );
////                    if ( !r.second ) r.first->second++;
////                    if ( fwd == curr ) continue;
////                    r = fwd->pairs_.insert( make_pair( curr, 1 ) );
////                    if ( !r.second ) r.first->second++;
////                }
////            }
////            
////            curr->removeMarks( usedIds, false, false, !drxn );
////            for ( Node* fwd : curr->getDrxnNodes( drxn, false, true ) ) fwd->removeMarks( usedIds, false, true, drxn );
////        }
//        
//        for ( Node* curr : currSet )
//        {
//            usedSet.insert( curr );
//            int maxReads = 0;
//            for ( Node* nxt : curr->getNextNodes( drxn ) )
//            {
//                int readCount = 0;
//                for ( Node* fwd : nxt->getDrxnNodes( drxn, false, true ) ) readCount += fwd->reads_.size();
//                maxReads = max( maxReads, readCount );
//            }
//            for ( Node* nxt : curr->getNextNodes( drxn ) )
//            {
//                if ( !nxt->stop_[drxn] && nxt->reads_.size() <= 2 && maxReads > 2 )
//                {
//                    nxt->dismantleNode();
//                    delSet.insert( nxt );
//                }
////                    int score[2]{0};
////                    for ( Node* fwd : nxt->getDrxnNodes( drxn, false, true ) )
////                    {
////                        score[0] += fwd->marks_[drxn].size();
////                        score[1] += fwd->getPairHitsTotal();
////                    }
////                    if ( !score[1] && score[0] > 4 && false ) nxt->dismantleNode( delSet, drxn );
//                else if ( usedSet.find( nxt ) == usedSet.end() ) nxtSet.insert( nxt );
//            }
//        }
//        currSet = nxtSet;
//    }
    for ( Node* node : nodes )
    {
        for ( Node* nxt : node->getNextNodes( drxn ) )
        {
            int readCount = 0;
            for ( Node* fwd : nxt->getDrxnNodes( drxn, false, true ) )
            {
                for ( auto read : fwd->reads_ ) if ( read.second[1] - read.second[0] == params.readLen ) readCount++;
            }
            if ( readCount <= 2 )
            {
                nxt->dismantleNode();
                delSet.insert( nxt );
            }
        }
        int thisCount = 0;
        for ( auto read : node->reads_ ) if ( read.second[1] - read.second[0] == params.readLen ) thisCount++;
        if ( thisCount < 2 && node->edges_[!drxn].empty() )
        {
            node->dismantleNode();
            delSet.insert( node );
        }
        node->sortEdges( 0 );
        node->sortEdges( 1 );
    }
    
    struct EdgeScore
    {
        EdgeScore( Edge &e, NodeSet &tSet, bool d )
        : n( e.node ), olPref( false ), hitPref( false ), altPref( false )
        {
            NodeList tNodes;
            for ( Edge &re : n->edges_[!d] ) if ( re.overlap > e.overlap ) olPref = true;
            for ( Node* bck : n->getDrxnNodes( !d ) ) tNodes.push_back( bck );
            for ( Node* fwd : n->getDrxnNodes( d, false, true ) )
            {
                for ( ReadMark &mark : fwd->marks_[d] )
                {
                    for ( Node* t : tNodes )
                    {
                        if ( t->reads_.find( mark.id ) == t->reads_.end() ) continue;
                        if ( tSet.find( t ) != tSet.end() ) hitPref = true;
                        else altPref = true;
                    }
                }
            }
        };
        Node* n;
        bool olPref, hitPref, altPref;
    };
    for ( Node* node : nodes )
    {
        if ( node->edges_[drxn].size() < 2 ) continue;
//        if ( node->seq_.find( "CAAAGTTCTGTTTGTTTAAAGTAGTGCTTGCA" ) != node->seq_.npos )
//        {
//            int x = 0;
//        }
        NodeSet tSet = node->getDrxnNodes( !drxn, false, true );
        vector<EdgeScore> edges;
        bool anyPref = false;
        for ( Edge &e : node->edges_[drxn] )
        {
            EdgeScore edge( e, tSet, drxn );
            edges.push_back( edge );
            if ( edge.hitPref || ( !edge.altPref && !edge.olPref ) ) anyPref = true;
        }
        if ( !anyPref ) continue;
        for ( EdgeScore &e : edges )
        {
            if ( e.hitPref || ( !e.altPref && !e.olPref ) ) continue;
            node->removeEdge( e.n, drxn );
            e.n->removeEdge( node, !drxn );
        }
    }
    
    for ( Node* node : nodes )
    {
        if ( delSet.find( node ) != delSet.end() ) continue;
        if ( node->seedDiminutive() )
        {
            node->dismantleNode();
            delSet.insert( node );
        }
    }
}

void Node::seedValidate( NodeSet &delSet, bool drxn )
{
    int minReads = 10;
    NodeIntMap scores;
    NodeList tNodes;
    for ( Node* bck : getDrxnNodes( !drxn, false, true ) ) tNodes.push_back( bck );
    for ( Node* fwd : getDrxnNodes( drxn ) )
    {
        int score = 0;
        for ( ReadMark &mark : fwd->marks_[drxn] )
        {
            for ( Node* t : tNodes )
            {
                if ( t->reads_.find( mark.id ) != t->reads_.end() ) score++;
            }
        }
        if ( score ) scores[fwd] = score;
    }
    for ( Node* nxt : getNextNodes( drxn ) )
    {
        if ( nxt->edges_[!drxn].size() > 1 ) return;
    }
    for ( Node* nxt : getNextNodes( drxn ) )
    {
        int readCount = 0, score = 0;
        bool doesContinue = false;
        for ( Node* fwd : nxt->getDrxnNodes( drxn, false, true ) )
        {
            readCount += fwd->reads_.size();
            if ( fwd->isContinue( drxn ) ) doesContinue = true;
            auto it = scores.find( fwd );
            if ( it != scores.end() ) score += it->second;
        }
        if ( score || ( readCount < 5 && doesContinue ) ) continue;
        if ( scores.empty() )
        {
            for ( Node* fwd : nxt->getDrxnNodes( drxn, false, true ) ) fwd->stop_[drxn] = 1;
        }
        else
        {
            removeEdge( nxt, drxn );
            nxt->removeEdge( this, !drxn );
            if ( nxt->edges_[!drxn].empty() ) nxt->dismantleNode( delSet, drxn );
        }
    }
}

void Node::setIds( int &id, bool drxn )
{
    if ( id2_ < 0 ) id2_ = id++;
    int i = 0;
    for ( Edge &e : edges_[drxn] )
    {
        if ( e.node->id2_ >= 0 ) continue;
        NodeSet nxtSet = e.node->getNextNodes( drxn );
        int32_t off = ends_[drxn] - e.node->ends_[!drxn] + ( drxn ? -e.overlap : e.overlap );
        e.node->offset( off );
        e.node->id2_ = id++;
        for ( int j = i + 1; j < edges_[drxn].size(); j++ )
        {
            bool independent = false;
            for ( Node* nxt : edges_[drxn][j].node->getNextNodes( drxn ) )
            {
                if ( nxtSet.find( nxt ) == nxtSet.end() ) independent = true;
            }
            if ( independent ) continue;
            off = ends_[drxn] - edges_[drxn][j].node->ends_[!drxn] + ( drxn ? -edges_[drxn][j].overlap : edges_[drxn][j].overlap ); 
            edges_[drxn][j].node->offset( off );
            edges_[drxn][j].node->id2_ = id++;
        }
        e.node->setIds( id, drxn );
        i++;
    }
}
